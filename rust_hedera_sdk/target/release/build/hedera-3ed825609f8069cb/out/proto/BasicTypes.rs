// This file is generated by rust-protobuf 2.3.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct ShardID {
    // message fields
    pub shardNum: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ShardID {
    pub fn new() -> ShardID {
        ::std::default::Default::default()
    }

    // int64 shardNum = 1;

    pub fn clear_shardNum(&mut self) {
        self.shardNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_shardNum(&mut self, v: i64) {
        self.shardNum = v;
    }

    pub fn get_shardNum(&self) -> i64 {
        self.shardNum
    }
}

impl ::protobuf::Message for ShardID {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.shardNum = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.shardNum != 0 {
            my_size += ::protobuf::rt::value_size(1, self.shardNum, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.shardNum != 0 {
            os.write_int64(1, self.shardNum)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShardID {
        ShardID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "shardNum",
                    |m: &ShardID| { &m.shardNum },
                    |m: &mut ShardID| { &mut m.shardNum },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ShardID>(
                    "ShardID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ShardID {
        static mut instance: ::protobuf::lazy::Lazy<ShardID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ShardID,
        };
        unsafe {
            instance.get(ShardID::new)
        }
    }
}

impl ::protobuf::Clear for ShardID {
    fn clear(&mut self) {
        self.clear_shardNum();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShardID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShardID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RealmID {
    // message fields
    pub shardNum: i64,
    pub realmNum: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl RealmID {
    pub fn new() -> RealmID {
        ::std::default::Default::default()
    }

    // int64 shardNum = 1;

    pub fn clear_shardNum(&mut self) {
        self.shardNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_shardNum(&mut self, v: i64) {
        self.shardNum = v;
    }

    pub fn get_shardNum(&self) -> i64 {
        self.shardNum
    }

    // int64 realmNum = 2;

    pub fn clear_realmNum(&mut self) {
        self.realmNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_realmNum(&mut self, v: i64) {
        self.realmNum = v;
    }

    pub fn get_realmNum(&self) -> i64 {
        self.realmNum
    }
}

impl ::protobuf::Message for RealmID {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.shardNum = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.realmNum = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.shardNum != 0 {
            my_size += ::protobuf::rt::value_size(1, self.shardNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.realmNum != 0 {
            my_size += ::protobuf::rt::value_size(2, self.realmNum, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.shardNum != 0 {
            os.write_int64(1, self.shardNum)?;
        }
        if self.realmNum != 0 {
            os.write_int64(2, self.realmNum)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RealmID {
        RealmID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "shardNum",
                    |m: &RealmID| { &m.shardNum },
                    |m: &mut RealmID| { &mut m.shardNum },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "realmNum",
                    |m: &RealmID| { &m.realmNum },
                    |m: &mut RealmID| { &mut m.realmNum },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RealmID>(
                    "RealmID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RealmID {
        static mut instance: ::protobuf::lazy::Lazy<RealmID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RealmID,
        };
        unsafe {
            instance.get(RealmID::new)
        }
    }
}

impl ::protobuf::Clear for RealmID {
    fn clear(&mut self) {
        self.clear_shardNum();
        self.clear_realmNum();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RealmID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RealmID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AccountID {
    // message fields
    pub shardNum: i64,
    pub realmNum: i64,
    pub accountNum: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AccountID {
    pub fn new() -> AccountID {
        ::std::default::Default::default()
    }

    // int64 shardNum = 1;

    pub fn clear_shardNum(&mut self) {
        self.shardNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_shardNum(&mut self, v: i64) {
        self.shardNum = v;
    }

    pub fn get_shardNum(&self) -> i64 {
        self.shardNum
    }

    // int64 realmNum = 2;

    pub fn clear_realmNum(&mut self) {
        self.realmNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_realmNum(&mut self, v: i64) {
        self.realmNum = v;
    }

    pub fn get_realmNum(&self) -> i64 {
        self.realmNum
    }

    // int64 accountNum = 3;

    pub fn clear_accountNum(&mut self) {
        self.accountNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_accountNum(&mut self, v: i64) {
        self.accountNum = v;
    }

    pub fn get_accountNum(&self) -> i64 {
        self.accountNum
    }
}

impl ::protobuf::Message for AccountID {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.shardNum = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.realmNum = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.accountNum = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.shardNum != 0 {
            my_size += ::protobuf::rt::value_size(1, self.shardNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.realmNum != 0 {
            my_size += ::protobuf::rt::value_size(2, self.realmNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.accountNum != 0 {
            my_size += ::protobuf::rt::value_size(3, self.accountNum, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.shardNum != 0 {
            os.write_int64(1, self.shardNum)?;
        }
        if self.realmNum != 0 {
            os.write_int64(2, self.realmNum)?;
        }
        if self.accountNum != 0 {
            os.write_int64(3, self.accountNum)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountID {
        AccountID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "shardNum",
                    |m: &AccountID| { &m.shardNum },
                    |m: &mut AccountID| { &mut m.shardNum },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "realmNum",
                    |m: &AccountID| { &m.realmNum },
                    |m: &mut AccountID| { &mut m.realmNum },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "accountNum",
                    |m: &AccountID| { &m.accountNum },
                    |m: &mut AccountID| { &mut m.accountNum },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AccountID>(
                    "AccountID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AccountID {
        static mut instance: ::protobuf::lazy::Lazy<AccountID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AccountID,
        };
        unsafe {
            instance.get(AccountID::new)
        }
    }
}

impl ::protobuf::Clear for AccountID {
    fn clear(&mut self) {
        self.clear_shardNum();
        self.clear_realmNum();
        self.clear_accountNum();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FileID {
    // message fields
    pub shardNum: i64,
    pub realmNum: i64,
    pub fileNum: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FileID {
    pub fn new() -> FileID {
        ::std::default::Default::default()
    }

    // int64 shardNum = 1;

    pub fn clear_shardNum(&mut self) {
        self.shardNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_shardNum(&mut self, v: i64) {
        self.shardNum = v;
    }

    pub fn get_shardNum(&self) -> i64 {
        self.shardNum
    }

    // int64 realmNum = 2;

    pub fn clear_realmNum(&mut self) {
        self.realmNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_realmNum(&mut self, v: i64) {
        self.realmNum = v;
    }

    pub fn get_realmNum(&self) -> i64 {
        self.realmNum
    }

    // int64 fileNum = 3;

    pub fn clear_fileNum(&mut self) {
        self.fileNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_fileNum(&mut self, v: i64) {
        self.fileNum = v;
    }

    pub fn get_fileNum(&self) -> i64 {
        self.fileNum
    }
}

impl ::protobuf::Message for FileID {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.shardNum = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.realmNum = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fileNum = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.shardNum != 0 {
            my_size += ::protobuf::rt::value_size(1, self.shardNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.realmNum != 0 {
            my_size += ::protobuf::rt::value_size(2, self.realmNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fileNum != 0 {
            my_size += ::protobuf::rt::value_size(3, self.fileNum, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.shardNum != 0 {
            os.write_int64(1, self.shardNum)?;
        }
        if self.realmNum != 0 {
            os.write_int64(2, self.realmNum)?;
        }
        if self.fileNum != 0 {
            os.write_int64(3, self.fileNum)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FileID {
        FileID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "shardNum",
                    |m: &FileID| { &m.shardNum },
                    |m: &mut FileID| { &mut m.shardNum },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "realmNum",
                    |m: &FileID| { &m.realmNum },
                    |m: &mut FileID| { &mut m.realmNum },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "fileNum",
                    |m: &FileID| { &m.fileNum },
                    |m: &mut FileID| { &mut m.fileNum },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FileID>(
                    "FileID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FileID {
        static mut instance: ::protobuf::lazy::Lazy<FileID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FileID,
        };
        unsafe {
            instance.get(FileID::new)
        }
    }
}

impl ::protobuf::Clear for FileID {
    fn clear(&mut self) {
        self.clear_shardNum();
        self.clear_realmNum();
        self.clear_fileNum();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FileID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FileID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContractID {
    // message fields
    pub shardNum: i64,
    pub realmNum: i64,
    pub contractNum: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ContractID {
    pub fn new() -> ContractID {
        ::std::default::Default::default()
    }

    // int64 shardNum = 1;

    pub fn clear_shardNum(&mut self) {
        self.shardNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_shardNum(&mut self, v: i64) {
        self.shardNum = v;
    }

    pub fn get_shardNum(&self) -> i64 {
        self.shardNum
    }

    // int64 realmNum = 2;

    pub fn clear_realmNum(&mut self) {
        self.realmNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_realmNum(&mut self, v: i64) {
        self.realmNum = v;
    }

    pub fn get_realmNum(&self) -> i64 {
        self.realmNum
    }

    // int64 contractNum = 3;

    pub fn clear_contractNum(&mut self) {
        self.contractNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_contractNum(&mut self, v: i64) {
        self.contractNum = v;
    }

    pub fn get_contractNum(&self) -> i64 {
        self.contractNum
    }
}

impl ::protobuf::Message for ContractID {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.shardNum = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.realmNum = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.contractNum = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.shardNum != 0 {
            my_size += ::protobuf::rt::value_size(1, self.shardNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.realmNum != 0 {
            my_size += ::protobuf::rt::value_size(2, self.realmNum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.contractNum != 0 {
            my_size += ::protobuf::rt::value_size(3, self.contractNum, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.shardNum != 0 {
            os.write_int64(1, self.shardNum)?;
        }
        if self.realmNum != 0 {
            os.write_int64(2, self.realmNum)?;
        }
        if self.contractNum != 0 {
            os.write_int64(3, self.contractNum)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContractID {
        ContractID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "shardNum",
                    |m: &ContractID| { &m.shardNum },
                    |m: &mut ContractID| { &mut m.shardNum },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "realmNum",
                    |m: &ContractID| { &m.realmNum },
                    |m: &mut ContractID| { &mut m.realmNum },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "contractNum",
                    |m: &ContractID| { &m.contractNum },
                    |m: &mut ContractID| { &mut m.contractNum },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ContractID>(
                    "ContractID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ContractID {
        static mut instance: ::protobuf::lazy::Lazy<ContractID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ContractID,
        };
        unsafe {
            instance.get(ContractID::new)
        }
    }
}

impl ::protobuf::Clear for ContractID {
    fn clear(&mut self) {
        self.clear_shardNum();
        self.clear_realmNum();
        self.clear_contractNum();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContractID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContractID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionID {
    // message fields
    pub transactionValidStart: ::protobuf::SingularPtrField<super::Timestamp::Timestamp>,
    pub accountID: ::protobuf::SingularPtrField<AccountID>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TransactionID {
    pub fn new() -> TransactionID {
        ::std::default::Default::default()
    }

    // .proto.Timestamp transactionValidStart = 1;

    pub fn clear_transactionValidStart(&mut self) {
        self.transactionValidStart.clear();
    }

    pub fn has_transactionValidStart(&self) -> bool {
        self.transactionValidStart.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transactionValidStart(&mut self, v: super::Timestamp::Timestamp) {
        self.transactionValidStart = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transactionValidStart(&mut self) -> &mut super::Timestamp::Timestamp {
        if self.transactionValidStart.is_none() {
            self.transactionValidStart.set_default();
        }
        self.transactionValidStart.as_mut().unwrap()
    }

    // Take field
    pub fn take_transactionValidStart(&mut self) -> super::Timestamp::Timestamp {
        self.transactionValidStart.take().unwrap_or_else(|| super::Timestamp::Timestamp::new())
    }

    pub fn get_transactionValidStart(&self) -> &super::Timestamp::Timestamp {
        self.transactionValidStart.as_ref().unwrap_or_else(|| super::Timestamp::Timestamp::default_instance())
    }

    // .proto.AccountID accountID = 2;

    pub fn clear_accountID(&mut self) {
        self.accountID.clear();
    }

    pub fn has_accountID(&self) -> bool {
        self.accountID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountID(&mut self, v: AccountID) {
        self.accountID = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountID(&mut self) -> &mut AccountID {
        if self.accountID.is_none() {
            self.accountID.set_default();
        }
        self.accountID.as_mut().unwrap()
    }

    // Take field
    pub fn take_accountID(&mut self) -> AccountID {
        self.accountID.take().unwrap_or_else(|| AccountID::new())
    }

    pub fn get_accountID(&self) -> &AccountID {
        self.accountID.as_ref().unwrap_or_else(|| AccountID::default_instance())
    }
}

impl ::protobuf::Message for TransactionID {
    fn is_initialized(&self) -> bool {
        for v in &self.transactionValidStart {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.accountID {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transactionValidStart)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.accountID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.transactionValidStart.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.accountID.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.transactionValidStart.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.accountID.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionID {
        TransactionID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Timestamp::Timestamp>>(
                    "transactionValidStart",
                    |m: &TransactionID| { &m.transactionValidStart },
                    |m: &mut TransactionID| { &mut m.transactionValidStart },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AccountID>>(
                    "accountID",
                    |m: &TransactionID| { &m.accountID },
                    |m: &mut TransactionID| { &mut m.accountID },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionID>(
                    "TransactionID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionID {
        static mut instance: ::protobuf::lazy::Lazy<TransactionID> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionID,
        };
        unsafe {
            instance.get(TransactionID::new)
        }
    }
}

impl ::protobuf::Clear for TransactionID {
    fn clear(&mut self) {
        self.clear_transactionValidStart();
        self.clear_accountID();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionID {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Key {
    // message oneof groups
    pub key: ::std::option::Option<Key_oneof_key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Key_oneof_key {
    contractID(ContractID),
    ed25519(::std::vec::Vec<u8>),
    RSA_3072(::std::vec::Vec<u8>),
    ECDSA_384(::std::vec::Vec<u8>),
    thresholdKey(ThresholdKey),
    keyList(KeyList),
}

impl Key {
    pub fn new() -> Key {
        ::std::default::Default::default()
    }

    // .proto.ContractID contractID = 1;

    pub fn clear_contractID(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_contractID(&self) -> bool {
        match self.key {
            ::std::option::Option::Some(Key_oneof_key::contractID(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contractID(&mut self, v: ContractID) {
        self.key = ::std::option::Option::Some(Key_oneof_key::contractID(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contractID(&mut self) -> &mut ContractID {
        if let ::std::option::Option::Some(Key_oneof_key::contractID(_)) = self.key {
        } else {
            self.key = ::std::option::Option::Some(Key_oneof_key::contractID(ContractID::new()));
        }
        match self.key {
            ::std::option::Option::Some(Key_oneof_key::contractID(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contractID(&mut self) -> ContractID {
        if self.has_contractID() {
            match self.key.take() {
                ::std::option::Option::Some(Key_oneof_key::contractID(v)) => v,
                _ => panic!(),
            }
        } else {
            ContractID::new()
        }
    }

    pub fn get_contractID(&self) -> &ContractID {
        match self.key {
            ::std::option::Option::Some(Key_oneof_key::contractID(ref v)) => v,
            _ => ContractID::default_instance(),
        }
    }

    // bytes ed25519 = 2;

    pub fn clear_ed25519(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_ed25519(&self) -> bool {
        match self.key {
            ::std::option::Option::Some(Key_oneof_key::ed25519(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ed25519(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::std::option::Option::Some(Key_oneof_key::ed25519(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ed25519(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(Key_oneof_key::ed25519(_)) = self.key {
        } else {
            self.key = ::std::option::Option::Some(Key_oneof_key::ed25519(::std::vec::Vec::new()));
        }
        match self.key {
            ::std::option::Option::Some(Key_oneof_key::ed25519(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ed25519(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_ed25519() {
            match self.key.take() {
                ::std::option::Option::Some(Key_oneof_key::ed25519(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    pub fn get_ed25519(&self) -> &[u8] {
        match self.key {
            ::std::option::Option::Some(Key_oneof_key::ed25519(ref v)) => v,
            _ => &[],
        }
    }

    // bytes RSA_3072 = 3;

    pub fn clear_RSA_3072(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_RSA_3072(&self) -> bool {
        match self.key {
            ::std::option::Option::Some(Key_oneof_key::RSA_3072(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_RSA_3072(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::std::option::Option::Some(Key_oneof_key::RSA_3072(v))
    }

    // Mutable pointer to the field.
    pub fn mut_RSA_3072(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(Key_oneof_key::RSA_3072(_)) = self.key {
        } else {
            self.key = ::std::option::Option::Some(Key_oneof_key::RSA_3072(::std::vec::Vec::new()));
        }
        match self.key {
            ::std::option::Option::Some(Key_oneof_key::RSA_3072(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_RSA_3072(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_RSA_3072() {
            match self.key.take() {
                ::std::option::Option::Some(Key_oneof_key::RSA_3072(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    pub fn get_RSA_3072(&self) -> &[u8] {
        match self.key {
            ::std::option::Option::Some(Key_oneof_key::RSA_3072(ref v)) => v,
            _ => &[],
        }
    }

    // bytes ECDSA_384 = 4;

    pub fn clear_ECDSA_384(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_ECDSA_384(&self) -> bool {
        match self.key {
            ::std::option::Option::Some(Key_oneof_key::ECDSA_384(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ECDSA_384(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = ::std::option::Option::Some(Key_oneof_key::ECDSA_384(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ECDSA_384(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(Key_oneof_key::ECDSA_384(_)) = self.key {
        } else {
            self.key = ::std::option::Option::Some(Key_oneof_key::ECDSA_384(::std::vec::Vec::new()));
        }
        match self.key {
            ::std::option::Option::Some(Key_oneof_key::ECDSA_384(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ECDSA_384(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_ECDSA_384() {
            match self.key.take() {
                ::std::option::Option::Some(Key_oneof_key::ECDSA_384(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    pub fn get_ECDSA_384(&self) -> &[u8] {
        match self.key {
            ::std::option::Option::Some(Key_oneof_key::ECDSA_384(ref v)) => v,
            _ => &[],
        }
    }

    // .proto.ThresholdKey thresholdKey = 5;

    pub fn clear_thresholdKey(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_thresholdKey(&self) -> bool {
        match self.key {
            ::std::option::Option::Some(Key_oneof_key::thresholdKey(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thresholdKey(&mut self, v: ThresholdKey) {
        self.key = ::std::option::Option::Some(Key_oneof_key::thresholdKey(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thresholdKey(&mut self) -> &mut ThresholdKey {
        if let ::std::option::Option::Some(Key_oneof_key::thresholdKey(_)) = self.key {
        } else {
            self.key = ::std::option::Option::Some(Key_oneof_key::thresholdKey(ThresholdKey::new()));
        }
        match self.key {
            ::std::option::Option::Some(Key_oneof_key::thresholdKey(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thresholdKey(&mut self) -> ThresholdKey {
        if self.has_thresholdKey() {
            match self.key.take() {
                ::std::option::Option::Some(Key_oneof_key::thresholdKey(v)) => v,
                _ => panic!(),
            }
        } else {
            ThresholdKey::new()
        }
    }

    pub fn get_thresholdKey(&self) -> &ThresholdKey {
        match self.key {
            ::std::option::Option::Some(Key_oneof_key::thresholdKey(ref v)) => v,
            _ => ThresholdKey::default_instance(),
        }
    }

    // .proto.KeyList keyList = 6;

    pub fn clear_keyList(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_keyList(&self) -> bool {
        match self.key {
            ::std::option::Option::Some(Key_oneof_key::keyList(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_keyList(&mut self, v: KeyList) {
        self.key = ::std::option::Option::Some(Key_oneof_key::keyList(v))
    }

    // Mutable pointer to the field.
    pub fn mut_keyList(&mut self) -> &mut KeyList {
        if let ::std::option::Option::Some(Key_oneof_key::keyList(_)) = self.key {
        } else {
            self.key = ::std::option::Option::Some(Key_oneof_key::keyList(KeyList::new()));
        }
        match self.key {
            ::std::option::Option::Some(Key_oneof_key::keyList(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_keyList(&mut self) -> KeyList {
        if self.has_keyList() {
            match self.key.take() {
                ::std::option::Option::Some(Key_oneof_key::keyList(v)) => v,
                _ => panic!(),
            }
        } else {
            KeyList::new()
        }
    }

    pub fn get_keyList(&self) -> &KeyList {
        match self.key {
            ::std::option::Option::Some(Key_oneof_key::keyList(ref v)) => v,
            _ => KeyList::default_instance(),
        }
    }
}

impl ::protobuf::Message for Key {
    fn is_initialized(&self) -> bool {
        if let Some(Key_oneof_key::contractID(ref v)) = self.key {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Key_oneof_key::thresholdKey(ref v)) = self.key {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Key_oneof_key::keyList(ref v)) = self.key {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.key = ::std::option::Option::Some(Key_oneof_key::contractID(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.key = ::std::option::Option::Some(Key_oneof_key::ed25519(is.read_bytes()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.key = ::std::option::Option::Some(Key_oneof_key::RSA_3072(is.read_bytes()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.key = ::std::option::Option::Some(Key_oneof_key::ECDSA_384(is.read_bytes()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.key = ::std::option::Option::Some(Key_oneof_key::thresholdKey(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.key = ::std::option::Option::Some(Key_oneof_key::keyList(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.key {
            match v {
                &Key_oneof_key::contractID(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Key_oneof_key::ed25519(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
                &Key_oneof_key::RSA_3072(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(3, &v);
                },
                &Key_oneof_key::ECDSA_384(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(4, &v);
                },
                &Key_oneof_key::thresholdKey(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Key_oneof_key::keyList(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.key {
            match v {
                &Key_oneof_key::contractID(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Key_oneof_key::ed25519(ref v) => {
                    os.write_bytes(2, v)?;
                },
                &Key_oneof_key::RSA_3072(ref v) => {
                    os.write_bytes(3, v)?;
                },
                &Key_oneof_key::ECDSA_384(ref v) => {
                    os.write_bytes(4, v)?;
                },
                &Key_oneof_key::thresholdKey(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Key_oneof_key::keyList(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Key {
        Key::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ContractID>(
                    "contractID",
                    Key::has_contractID,
                    Key::get_contractID,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "ed25519",
                    Key::has_ed25519,
                    Key::get_ed25519,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "RSA_3072",
                    Key::has_RSA_3072,
                    Key::get_RSA_3072,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "ECDSA_384",
                    Key::has_ECDSA_384,
                    Key::get_ECDSA_384,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ThresholdKey>(
                    "thresholdKey",
                    Key::has_thresholdKey,
                    Key::get_thresholdKey,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, KeyList>(
                    "keyList",
                    Key::has_keyList,
                    Key::get_keyList,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Key>(
                    "Key",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Key {
        static mut instance: ::protobuf::lazy::Lazy<Key> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Key,
        };
        unsafe {
            instance.get(Key::new)
        }
    }
}

impl ::protobuf::Clear for Key {
    fn clear(&mut self) {
        self.clear_contractID();
        self.clear_ed25519();
        self.clear_RSA_3072();
        self.clear_ECDSA_384();
        self.clear_thresholdKey();
        self.clear_keyList();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Key {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Key {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThresholdKey {
    // message fields
    pub threshold: u32,
    pub keys: ::protobuf::SingularPtrField<KeyList>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ThresholdKey {
    pub fn new() -> ThresholdKey {
        ::std::default::Default::default()
    }

    // uint32 threshold = 1;

    pub fn clear_threshold(&mut self) {
        self.threshold = 0;
    }

    // Param is passed by value, moved
    pub fn set_threshold(&mut self, v: u32) {
        self.threshold = v;
    }

    pub fn get_threshold(&self) -> u32 {
        self.threshold
    }

    // .proto.KeyList keys = 2;

    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    pub fn has_keys(&self) -> bool {
        self.keys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: KeyList) {
        self.keys = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keys(&mut self) -> &mut KeyList {
        if self.keys.is_none() {
            self.keys.set_default();
        }
        self.keys.as_mut().unwrap()
    }

    // Take field
    pub fn take_keys(&mut self) -> KeyList {
        self.keys.take().unwrap_or_else(|| KeyList::new())
    }

    pub fn get_keys(&self) -> &KeyList {
        self.keys.as_ref().unwrap_or_else(|| KeyList::default_instance())
    }
}

impl ::protobuf::Message for ThresholdKey {
    fn is_initialized(&self) -> bool {
        for v in &self.keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.threshold = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.threshold != 0 {
            my_size += ::protobuf::rt::value_size(1, self.threshold, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.keys.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.threshold != 0 {
            os.write_uint32(1, self.threshold)?;
        }
        if let Some(ref v) = self.keys.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThresholdKey {
        ThresholdKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "threshold",
                    |m: &ThresholdKey| { &m.threshold },
                    |m: &mut ThresholdKey| { &mut m.threshold },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyList>>(
                    "keys",
                    |m: &ThresholdKey| { &m.keys },
                    |m: &mut ThresholdKey| { &mut m.keys },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ThresholdKey>(
                    "ThresholdKey",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThresholdKey {
        static mut instance: ::protobuf::lazy::Lazy<ThresholdKey> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThresholdKey,
        };
        unsafe {
            instance.get(ThresholdKey::new)
        }
    }
}

impl ::protobuf::Clear for ThresholdKey {
    fn clear(&mut self) {
        self.clear_threshold();
        self.clear_keys();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThresholdKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThresholdKey {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyList {
    // message fields
    pub keys: ::protobuf::RepeatedField<Key>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl KeyList {
    pub fn new() -> KeyList {
        ::std::default::Default::default()
    }

    // repeated .proto.Key keys = 1;

    pub fn clear_keys(&mut self) {
        self.keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_keys(&mut self, v: ::protobuf::RepeatedField<Key>) {
        self.keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keys(&mut self) -> &mut ::protobuf::RepeatedField<Key> {
        &mut self.keys
    }

    // Take field
    pub fn take_keys(&mut self) -> ::protobuf::RepeatedField<Key> {
        ::std::mem::replace(&mut self.keys, ::protobuf::RepeatedField::new())
    }

    pub fn get_keys(&self) -> &[Key] {
        &self.keys
    }
}

impl ::protobuf::Message for KeyList {
    fn is_initialized(&self) -> bool {
        for v in &self.keys {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.keys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.keys {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyList {
        KeyList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Key>>(
                    "keys",
                    |m: &KeyList| { &m.keys },
                    |m: &mut KeyList| { &mut m.keys },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<KeyList>(
                    "KeyList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static KeyList {
        static mut instance: ::protobuf::lazy::Lazy<KeyList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const KeyList,
        };
        unsafe {
            instance.get(KeyList::new)
        }
    }
}

impl ::protobuf::Clear for KeyList {
    fn clear(&mut self) {
        self.clear_keys();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Signature {
    // message oneof groups
    pub signature: ::std::option::Option<Signature_oneof_signature>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Signature_oneof_signature {
    contract(::std::vec::Vec<u8>),
    ed25519(::std::vec::Vec<u8>),
    RSA_3072(::std::vec::Vec<u8>),
    ECDSA_384(::std::vec::Vec<u8>),
    thresholdSignature(ThresholdSignature),
    signatureList(SignatureList),
}

impl Signature {
    pub fn new() -> Signature {
        ::std::default::Default::default()
    }

    // bytes contract = 1;

    pub fn clear_contract(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_contract(&self) -> bool {
        match self.signature {
            ::std::option::Option::Some(Signature_oneof_signature::contract(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contract(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(Signature_oneof_signature::contract(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contract(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(Signature_oneof_signature::contract(_)) = self.signature {
        } else {
            self.signature = ::std::option::Option::Some(Signature_oneof_signature::contract(::std::vec::Vec::new()));
        }
        match self.signature {
            ::std::option::Option::Some(Signature_oneof_signature::contract(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contract(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_contract() {
            match self.signature.take() {
                ::std::option::Option::Some(Signature_oneof_signature::contract(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    pub fn get_contract(&self) -> &[u8] {
        match self.signature {
            ::std::option::Option::Some(Signature_oneof_signature::contract(ref v)) => v,
            _ => &[],
        }
    }

    // bytes ed25519 = 2;

    pub fn clear_ed25519(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_ed25519(&self) -> bool {
        match self.signature {
            ::std::option::Option::Some(Signature_oneof_signature::ed25519(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ed25519(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(Signature_oneof_signature::ed25519(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ed25519(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(Signature_oneof_signature::ed25519(_)) = self.signature {
        } else {
            self.signature = ::std::option::Option::Some(Signature_oneof_signature::ed25519(::std::vec::Vec::new()));
        }
        match self.signature {
            ::std::option::Option::Some(Signature_oneof_signature::ed25519(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ed25519(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_ed25519() {
            match self.signature.take() {
                ::std::option::Option::Some(Signature_oneof_signature::ed25519(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    pub fn get_ed25519(&self) -> &[u8] {
        match self.signature {
            ::std::option::Option::Some(Signature_oneof_signature::ed25519(ref v)) => v,
            _ => &[],
        }
    }

    // bytes RSA_3072 = 3;

    pub fn clear_RSA_3072(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_RSA_3072(&self) -> bool {
        match self.signature {
            ::std::option::Option::Some(Signature_oneof_signature::RSA_3072(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_RSA_3072(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(Signature_oneof_signature::RSA_3072(v))
    }

    // Mutable pointer to the field.
    pub fn mut_RSA_3072(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(Signature_oneof_signature::RSA_3072(_)) = self.signature {
        } else {
            self.signature = ::std::option::Option::Some(Signature_oneof_signature::RSA_3072(::std::vec::Vec::new()));
        }
        match self.signature {
            ::std::option::Option::Some(Signature_oneof_signature::RSA_3072(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_RSA_3072(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_RSA_3072() {
            match self.signature.take() {
                ::std::option::Option::Some(Signature_oneof_signature::RSA_3072(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    pub fn get_RSA_3072(&self) -> &[u8] {
        match self.signature {
            ::std::option::Option::Some(Signature_oneof_signature::RSA_3072(ref v)) => v,
            _ => &[],
        }
    }

    // bytes ECDSA_384 = 4;

    pub fn clear_ECDSA_384(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_ECDSA_384(&self) -> bool {
        match self.signature {
            ::std::option::Option::Some(Signature_oneof_signature::ECDSA_384(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ECDSA_384(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = ::std::option::Option::Some(Signature_oneof_signature::ECDSA_384(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ECDSA_384(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(Signature_oneof_signature::ECDSA_384(_)) = self.signature {
        } else {
            self.signature = ::std::option::Option::Some(Signature_oneof_signature::ECDSA_384(::std::vec::Vec::new()));
        }
        match self.signature {
            ::std::option::Option::Some(Signature_oneof_signature::ECDSA_384(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ECDSA_384(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_ECDSA_384() {
            match self.signature.take() {
                ::std::option::Option::Some(Signature_oneof_signature::ECDSA_384(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    pub fn get_ECDSA_384(&self) -> &[u8] {
        match self.signature {
            ::std::option::Option::Some(Signature_oneof_signature::ECDSA_384(ref v)) => v,
            _ => &[],
        }
    }

    // .proto.ThresholdSignature thresholdSignature = 5;

    pub fn clear_thresholdSignature(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_thresholdSignature(&self) -> bool {
        match self.signature {
            ::std::option::Option::Some(Signature_oneof_signature::thresholdSignature(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_thresholdSignature(&mut self, v: ThresholdSignature) {
        self.signature = ::std::option::Option::Some(Signature_oneof_signature::thresholdSignature(v))
    }

    // Mutable pointer to the field.
    pub fn mut_thresholdSignature(&mut self) -> &mut ThresholdSignature {
        if let ::std::option::Option::Some(Signature_oneof_signature::thresholdSignature(_)) = self.signature {
        } else {
            self.signature = ::std::option::Option::Some(Signature_oneof_signature::thresholdSignature(ThresholdSignature::new()));
        }
        match self.signature {
            ::std::option::Option::Some(Signature_oneof_signature::thresholdSignature(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_thresholdSignature(&mut self) -> ThresholdSignature {
        if self.has_thresholdSignature() {
            match self.signature.take() {
                ::std::option::Option::Some(Signature_oneof_signature::thresholdSignature(v)) => v,
                _ => panic!(),
            }
        } else {
            ThresholdSignature::new()
        }
    }

    pub fn get_thresholdSignature(&self) -> &ThresholdSignature {
        match self.signature {
            ::std::option::Option::Some(Signature_oneof_signature::thresholdSignature(ref v)) => v,
            _ => ThresholdSignature::default_instance(),
        }
    }

    // .proto.SignatureList signatureList = 6;

    pub fn clear_signatureList(&mut self) {
        self.signature = ::std::option::Option::None;
    }

    pub fn has_signatureList(&self) -> bool {
        match self.signature {
            ::std::option::Option::Some(Signature_oneof_signature::signatureList(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_signatureList(&mut self, v: SignatureList) {
        self.signature = ::std::option::Option::Some(Signature_oneof_signature::signatureList(v))
    }

    // Mutable pointer to the field.
    pub fn mut_signatureList(&mut self) -> &mut SignatureList {
        if let ::std::option::Option::Some(Signature_oneof_signature::signatureList(_)) = self.signature {
        } else {
            self.signature = ::std::option::Option::Some(Signature_oneof_signature::signatureList(SignatureList::new()));
        }
        match self.signature {
            ::std::option::Option::Some(Signature_oneof_signature::signatureList(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_signatureList(&mut self) -> SignatureList {
        if self.has_signatureList() {
            match self.signature.take() {
                ::std::option::Option::Some(Signature_oneof_signature::signatureList(v)) => v,
                _ => panic!(),
            }
        } else {
            SignatureList::new()
        }
    }

    pub fn get_signatureList(&self) -> &SignatureList {
        match self.signature {
            ::std::option::Option::Some(Signature_oneof_signature::signatureList(ref v)) => v,
            _ => SignatureList::default_instance(),
        }
    }
}

impl ::protobuf::Message for Signature {
    fn is_initialized(&self) -> bool {
        if let Some(Signature_oneof_signature::thresholdSignature(ref v)) = self.signature {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Signature_oneof_signature::signatureList(ref v)) = self.signature {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.signature = ::std::option::Option::Some(Signature_oneof_signature::contract(is.read_bytes()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.signature = ::std::option::Option::Some(Signature_oneof_signature::ed25519(is.read_bytes()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.signature = ::std::option::Option::Some(Signature_oneof_signature::RSA_3072(is.read_bytes()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.signature = ::std::option::Option::Some(Signature_oneof_signature::ECDSA_384(is.read_bytes()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.signature = ::std::option::Option::Some(Signature_oneof_signature::thresholdSignature(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.signature = ::std::option::Option::Some(Signature_oneof_signature::signatureList(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.signature {
            match v {
                &Signature_oneof_signature::contract(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(1, &v);
                },
                &Signature_oneof_signature::ed25519(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                },
                &Signature_oneof_signature::RSA_3072(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(3, &v);
                },
                &Signature_oneof_signature::ECDSA_384(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(4, &v);
                },
                &Signature_oneof_signature::thresholdSignature(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Signature_oneof_signature::signatureList(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.signature {
            match v {
                &Signature_oneof_signature::contract(ref v) => {
                    os.write_bytes(1, v)?;
                },
                &Signature_oneof_signature::ed25519(ref v) => {
                    os.write_bytes(2, v)?;
                },
                &Signature_oneof_signature::RSA_3072(ref v) => {
                    os.write_bytes(3, v)?;
                },
                &Signature_oneof_signature::ECDSA_384(ref v) => {
                    os.write_bytes(4, v)?;
                },
                &Signature_oneof_signature::thresholdSignature(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Signature_oneof_signature::signatureList(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Signature {
        Signature::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "contract",
                    Signature::has_contract,
                    Signature::get_contract,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "ed25519",
                    Signature::has_ed25519,
                    Signature::get_ed25519,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "RSA_3072",
                    Signature::has_RSA_3072,
                    Signature::get_RSA_3072,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                    "ECDSA_384",
                    Signature::has_ECDSA_384,
                    Signature::get_ECDSA_384,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ThresholdSignature>(
                    "thresholdSignature",
                    Signature::has_thresholdSignature,
                    Signature::get_thresholdSignature,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SignatureList>(
                    "signatureList",
                    Signature::has_signatureList,
                    Signature::get_signatureList,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Signature>(
                    "Signature",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Signature {
        static mut instance: ::protobuf::lazy::Lazy<Signature> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Signature,
        };
        unsafe {
            instance.get(Signature::new)
        }
    }
}

impl ::protobuf::Clear for Signature {
    fn clear(&mut self) {
        self.clear_contract();
        self.clear_ed25519();
        self.clear_RSA_3072();
        self.clear_ECDSA_384();
        self.clear_thresholdSignature();
        self.clear_signatureList();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Signature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Signature {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ThresholdSignature {
    // message fields
    pub sigs: ::protobuf::SingularPtrField<SignatureList>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl ThresholdSignature {
    pub fn new() -> ThresholdSignature {
        ::std::default::Default::default()
    }

    // .proto.SignatureList sigs = 2;

    pub fn clear_sigs(&mut self) {
        self.sigs.clear();
    }

    pub fn has_sigs(&self) -> bool {
        self.sigs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sigs(&mut self, v: SignatureList) {
        self.sigs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sigs(&mut self) -> &mut SignatureList {
        if self.sigs.is_none() {
            self.sigs.set_default();
        }
        self.sigs.as_mut().unwrap()
    }

    // Take field
    pub fn take_sigs(&mut self) -> SignatureList {
        self.sigs.take().unwrap_or_else(|| SignatureList::new())
    }

    pub fn get_sigs(&self) -> &SignatureList {
        self.sigs.as_ref().unwrap_or_else(|| SignatureList::default_instance())
    }
}

impl ::protobuf::Message for ThresholdSignature {
    fn is_initialized(&self) -> bool {
        for v in &self.sigs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sigs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.sigs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.sigs.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ThresholdSignature {
        ThresholdSignature::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SignatureList>>(
                    "sigs",
                    |m: &ThresholdSignature| { &m.sigs },
                    |m: &mut ThresholdSignature| { &mut m.sigs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ThresholdSignature>(
                    "ThresholdSignature",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ThresholdSignature {
        static mut instance: ::protobuf::lazy::Lazy<ThresholdSignature> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ThresholdSignature,
        };
        unsafe {
            instance.get(ThresholdSignature::new)
        }
    }
}

impl ::protobuf::Clear for ThresholdSignature {
    fn clear(&mut self) {
        self.clear_sigs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ThresholdSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ThresholdSignature {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SignatureList {
    // message fields
    pub sigs: ::protobuf::RepeatedField<Signature>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl SignatureList {
    pub fn new() -> SignatureList {
        ::std::default::Default::default()
    }

    // repeated .proto.Signature sigs = 2;

    pub fn clear_sigs(&mut self) {
        self.sigs.clear();
    }

    // Param is passed by value, moved
    pub fn set_sigs(&mut self, v: ::protobuf::RepeatedField<Signature>) {
        self.sigs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sigs(&mut self) -> &mut ::protobuf::RepeatedField<Signature> {
        &mut self.sigs
    }

    // Take field
    pub fn take_sigs(&mut self) -> ::protobuf::RepeatedField<Signature> {
        ::std::mem::replace(&mut self.sigs, ::protobuf::RepeatedField::new())
    }

    pub fn get_sigs(&self) -> &[Signature] {
        &self.sigs
    }
}

impl ::protobuf::Message for SignatureList {
    fn is_initialized(&self) -> bool {
        for v in &self.sigs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sigs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sigs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sigs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignatureList {
        SignatureList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Signature>>(
                    "sigs",
                    |m: &SignatureList| { &m.sigs },
                    |m: &mut SignatureList| { &mut m.sigs },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SignatureList>(
                    "SignatureList",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SignatureList {
        static mut instance: ::protobuf::lazy::Lazy<SignatureList> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SignatureList,
        };
        unsafe {
            instance.get(SignatureList::new)
        }
    }
}

impl ::protobuf::Clear for SignatureList {
    fn clear(&mut self) {
        self.clear_sigs();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignatureList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignatureList {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeeComponents {
    // message fields
    pub min: i64,
    pub max: i64,
    pub constant: i64,
    pub bpt: i64,
    pub vpt: i64,
    pub rbs: i64,
    pub sbs: i64,
    pub gas: i64,
    pub tv: i64,
    pub bpr: i64,
    pub sbpr: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FeeComponents {
    pub fn new() -> FeeComponents {
        ::std::default::Default::default()
    }

    // int64 min = 1;

    pub fn clear_min(&mut self) {
        self.min = 0;
    }

    // Param is passed by value, moved
    pub fn set_min(&mut self, v: i64) {
        self.min = v;
    }

    pub fn get_min(&self) -> i64 {
        self.min
    }

    // int64 max = 2;

    pub fn clear_max(&mut self) {
        self.max = 0;
    }

    // Param is passed by value, moved
    pub fn set_max(&mut self, v: i64) {
        self.max = v;
    }

    pub fn get_max(&self) -> i64 {
        self.max
    }

    // int64 constant = 3;

    pub fn clear_constant(&mut self) {
        self.constant = 0;
    }

    // Param is passed by value, moved
    pub fn set_constant(&mut self, v: i64) {
        self.constant = v;
    }

    pub fn get_constant(&self) -> i64 {
        self.constant
    }

    // int64 bpt = 4;

    pub fn clear_bpt(&mut self) {
        self.bpt = 0;
    }

    // Param is passed by value, moved
    pub fn set_bpt(&mut self, v: i64) {
        self.bpt = v;
    }

    pub fn get_bpt(&self) -> i64 {
        self.bpt
    }

    // int64 vpt = 5;

    pub fn clear_vpt(&mut self) {
        self.vpt = 0;
    }

    // Param is passed by value, moved
    pub fn set_vpt(&mut self, v: i64) {
        self.vpt = v;
    }

    pub fn get_vpt(&self) -> i64 {
        self.vpt
    }

    // int64 rbs = 6;

    pub fn clear_rbs(&mut self) {
        self.rbs = 0;
    }

    // Param is passed by value, moved
    pub fn set_rbs(&mut self, v: i64) {
        self.rbs = v;
    }

    pub fn get_rbs(&self) -> i64 {
        self.rbs
    }

    // int64 sbs = 7;

    pub fn clear_sbs(&mut self) {
        self.sbs = 0;
    }

    // Param is passed by value, moved
    pub fn set_sbs(&mut self, v: i64) {
        self.sbs = v;
    }

    pub fn get_sbs(&self) -> i64 {
        self.sbs
    }

    // int64 gas = 8;

    pub fn clear_gas(&mut self) {
        self.gas = 0;
    }

    // Param is passed by value, moved
    pub fn set_gas(&mut self, v: i64) {
        self.gas = v;
    }

    pub fn get_gas(&self) -> i64 {
        self.gas
    }

    // int64 tv = 9;

    pub fn clear_tv(&mut self) {
        self.tv = 0;
    }

    // Param is passed by value, moved
    pub fn set_tv(&mut self, v: i64) {
        self.tv = v;
    }

    pub fn get_tv(&self) -> i64 {
        self.tv
    }

    // int64 bpr = 10;

    pub fn clear_bpr(&mut self) {
        self.bpr = 0;
    }

    // Param is passed by value, moved
    pub fn set_bpr(&mut self, v: i64) {
        self.bpr = v;
    }

    pub fn get_bpr(&self) -> i64 {
        self.bpr
    }

    // int64 sbpr = 11;

    pub fn clear_sbpr(&mut self) {
        self.sbpr = 0;
    }

    // Param is passed by value, moved
    pub fn set_sbpr(&mut self, v: i64) {
        self.sbpr = v;
    }

    pub fn get_sbpr(&self) -> i64 {
        self.sbpr
    }
}

impl ::protobuf::Message for FeeComponents {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.min = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.constant = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bpt = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.vpt = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.rbs = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sbs = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.gas = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tv = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bpr = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sbpr = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.min != 0 {
            my_size += ::protobuf::rt::value_size(1, self.min, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max != 0 {
            my_size += ::protobuf::rt::value_size(2, self.max, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.constant != 0 {
            my_size += ::protobuf::rt::value_size(3, self.constant, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.bpt != 0 {
            my_size += ::protobuf::rt::value_size(4, self.bpt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.vpt != 0 {
            my_size += ::protobuf::rt::value_size(5, self.vpt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rbs != 0 {
            my_size += ::protobuf::rt::value_size(6, self.rbs, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sbs != 0 {
            my_size += ::protobuf::rt::value_size(7, self.sbs, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.gas != 0 {
            my_size += ::protobuf::rt::value_size(8, self.gas, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.tv != 0 {
            my_size += ::protobuf::rt::value_size(9, self.tv, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.bpr != 0 {
            my_size += ::protobuf::rt::value_size(10, self.bpr, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.sbpr != 0 {
            my_size += ::protobuf::rt::value_size(11, self.sbpr, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.min != 0 {
            os.write_int64(1, self.min)?;
        }
        if self.max != 0 {
            os.write_int64(2, self.max)?;
        }
        if self.constant != 0 {
            os.write_int64(3, self.constant)?;
        }
        if self.bpt != 0 {
            os.write_int64(4, self.bpt)?;
        }
        if self.vpt != 0 {
            os.write_int64(5, self.vpt)?;
        }
        if self.rbs != 0 {
            os.write_int64(6, self.rbs)?;
        }
        if self.sbs != 0 {
            os.write_int64(7, self.sbs)?;
        }
        if self.gas != 0 {
            os.write_int64(8, self.gas)?;
        }
        if self.tv != 0 {
            os.write_int64(9, self.tv)?;
        }
        if self.bpr != 0 {
            os.write_int64(10, self.bpr)?;
        }
        if self.sbpr != 0 {
            os.write_int64(11, self.sbpr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeeComponents {
        FeeComponents::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "min",
                    |m: &FeeComponents| { &m.min },
                    |m: &mut FeeComponents| { &mut m.min },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "max",
                    |m: &FeeComponents| { &m.max },
                    |m: &mut FeeComponents| { &mut m.max },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "constant",
                    |m: &FeeComponents| { &m.constant },
                    |m: &mut FeeComponents| { &mut m.constant },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "bpt",
                    |m: &FeeComponents| { &m.bpt },
                    |m: &mut FeeComponents| { &mut m.bpt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "vpt",
                    |m: &FeeComponents| { &m.vpt },
                    |m: &mut FeeComponents| { &mut m.vpt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "rbs",
                    |m: &FeeComponents| { &m.rbs },
                    |m: &mut FeeComponents| { &mut m.rbs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "sbs",
                    |m: &FeeComponents| { &m.sbs },
                    |m: &mut FeeComponents| { &mut m.sbs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "gas",
                    |m: &FeeComponents| { &m.gas },
                    |m: &mut FeeComponents| { &mut m.gas },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "tv",
                    |m: &FeeComponents| { &m.tv },
                    |m: &mut FeeComponents| { &mut m.tv },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "bpr",
                    |m: &FeeComponents| { &m.bpr },
                    |m: &mut FeeComponents| { &mut m.bpr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "sbpr",
                    |m: &FeeComponents| { &m.sbpr },
                    |m: &mut FeeComponents| { &mut m.sbpr },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FeeComponents>(
                    "FeeComponents",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FeeComponents {
        static mut instance: ::protobuf::lazy::Lazy<FeeComponents> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FeeComponents,
        };
        unsafe {
            instance.get(FeeComponents::new)
        }
    }
}

impl ::protobuf::Clear for FeeComponents {
    fn clear(&mut self) {
        self.clear_min();
        self.clear_max();
        self.clear_constant();
        self.clear_bpt();
        self.clear_vpt();
        self.clear_rbs();
        self.clear_sbs();
        self.clear_gas();
        self.clear_tv();
        self.clear_bpr();
        self.clear_sbpr();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeeComponents {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeeComponents {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransactionFeeSchedule {
    // message fields
    pub hederaFunctionality: HederaFunctionality,
    pub feeData: ::protobuf::SingularPtrField<FeeData>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl TransactionFeeSchedule {
    pub fn new() -> TransactionFeeSchedule {
        ::std::default::Default::default()
    }

    // .proto.HederaFunctionality hederaFunctionality = 1;

    pub fn clear_hederaFunctionality(&mut self) {
        self.hederaFunctionality = HederaFunctionality::CryptoCreate;
    }

    // Param is passed by value, moved
    pub fn set_hederaFunctionality(&mut self, v: HederaFunctionality) {
        self.hederaFunctionality = v;
    }

    pub fn get_hederaFunctionality(&self) -> HederaFunctionality {
        self.hederaFunctionality
    }

    // .proto.FeeData feeData = 2;

    pub fn clear_feeData(&mut self) {
        self.feeData.clear();
    }

    pub fn has_feeData(&self) -> bool {
        self.feeData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feeData(&mut self, v: FeeData) {
        self.feeData = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_feeData(&mut self) -> &mut FeeData {
        if self.feeData.is_none() {
            self.feeData.set_default();
        }
        self.feeData.as_mut().unwrap()
    }

    // Take field
    pub fn take_feeData(&mut self) -> FeeData {
        self.feeData.take().unwrap_or_else(|| FeeData::new())
    }

    pub fn get_feeData(&self) -> &FeeData {
        self.feeData.as_ref().unwrap_or_else(|| FeeData::default_instance())
    }
}

impl ::protobuf::Message for TransactionFeeSchedule {
    fn is_initialized(&self) -> bool {
        for v in &self.feeData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.hederaFunctionality, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.feeData)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.hederaFunctionality != HederaFunctionality::CryptoCreate {
            my_size += ::protobuf::rt::enum_size(1, self.hederaFunctionality);
        }
        if let Some(ref v) = self.feeData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.hederaFunctionality != HederaFunctionality::CryptoCreate {
            os.write_enum(1, self.hederaFunctionality.value())?;
        }
        if let Some(ref v) = self.feeData.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransactionFeeSchedule {
        TransactionFeeSchedule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HederaFunctionality>>(
                    "hederaFunctionality",
                    |m: &TransactionFeeSchedule| { &m.hederaFunctionality },
                    |m: &mut TransactionFeeSchedule| { &mut m.hederaFunctionality },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeeData>>(
                    "feeData",
                    |m: &TransactionFeeSchedule| { &m.feeData },
                    |m: &mut TransactionFeeSchedule| { &mut m.feeData },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TransactionFeeSchedule>(
                    "TransactionFeeSchedule",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TransactionFeeSchedule {
        static mut instance: ::protobuf::lazy::Lazy<TransactionFeeSchedule> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TransactionFeeSchedule,
        };
        unsafe {
            instance.get(TransactionFeeSchedule::new)
        }
    }
}

impl ::protobuf::Clear for TransactionFeeSchedule {
    fn clear(&mut self) {
        self.clear_hederaFunctionality();
        self.clear_feeData();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransactionFeeSchedule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionFeeSchedule {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeeData {
    // message fields
    pub nodedata: ::protobuf::SingularPtrField<FeeComponents>,
    pub networkdata: ::protobuf::SingularPtrField<FeeComponents>,
    pub servicedata: ::protobuf::SingularPtrField<FeeComponents>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FeeData {
    pub fn new() -> FeeData {
        ::std::default::Default::default()
    }

    // .proto.FeeComponents nodedata = 1;

    pub fn clear_nodedata(&mut self) {
        self.nodedata.clear();
    }

    pub fn has_nodedata(&self) -> bool {
        self.nodedata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodedata(&mut self, v: FeeComponents) {
        self.nodedata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodedata(&mut self) -> &mut FeeComponents {
        if self.nodedata.is_none() {
            self.nodedata.set_default();
        }
        self.nodedata.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodedata(&mut self) -> FeeComponents {
        self.nodedata.take().unwrap_or_else(|| FeeComponents::new())
    }

    pub fn get_nodedata(&self) -> &FeeComponents {
        self.nodedata.as_ref().unwrap_or_else(|| FeeComponents::default_instance())
    }

    // .proto.FeeComponents networkdata = 2;

    pub fn clear_networkdata(&mut self) {
        self.networkdata.clear();
    }

    pub fn has_networkdata(&self) -> bool {
        self.networkdata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_networkdata(&mut self, v: FeeComponents) {
        self.networkdata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_networkdata(&mut self) -> &mut FeeComponents {
        if self.networkdata.is_none() {
            self.networkdata.set_default();
        }
        self.networkdata.as_mut().unwrap()
    }

    // Take field
    pub fn take_networkdata(&mut self) -> FeeComponents {
        self.networkdata.take().unwrap_or_else(|| FeeComponents::new())
    }

    pub fn get_networkdata(&self) -> &FeeComponents {
        self.networkdata.as_ref().unwrap_or_else(|| FeeComponents::default_instance())
    }

    // .proto.FeeComponents servicedata = 3;

    pub fn clear_servicedata(&mut self) {
        self.servicedata.clear();
    }

    pub fn has_servicedata(&self) -> bool {
        self.servicedata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_servicedata(&mut self, v: FeeComponents) {
        self.servicedata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_servicedata(&mut self) -> &mut FeeComponents {
        if self.servicedata.is_none() {
            self.servicedata.set_default();
        }
        self.servicedata.as_mut().unwrap()
    }

    // Take field
    pub fn take_servicedata(&mut self) -> FeeComponents {
        self.servicedata.take().unwrap_or_else(|| FeeComponents::new())
    }

    pub fn get_servicedata(&self) -> &FeeComponents {
        self.servicedata.as_ref().unwrap_or_else(|| FeeComponents::default_instance())
    }
}

impl ::protobuf::Message for FeeData {
    fn is_initialized(&self) -> bool {
        for v in &self.nodedata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.networkdata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.servicedata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nodedata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.networkdata)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.servicedata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.nodedata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.networkdata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.servicedata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.nodedata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.networkdata.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.servicedata.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeeData {
        FeeData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeeComponents>>(
                    "nodedata",
                    |m: &FeeData| { &m.nodedata },
                    |m: &mut FeeData| { &mut m.nodedata },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeeComponents>>(
                    "networkdata",
                    |m: &FeeData| { &m.networkdata },
                    |m: &mut FeeData| { &mut m.networkdata },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FeeComponents>>(
                    "servicedata",
                    |m: &FeeData| { &m.servicedata },
                    |m: &mut FeeData| { &mut m.servicedata },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FeeData>(
                    "FeeData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FeeData {
        static mut instance: ::protobuf::lazy::Lazy<FeeData> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FeeData,
        };
        unsafe {
            instance.get(FeeData::new)
        }
    }
}

impl ::protobuf::Clear for FeeData {
    fn clear(&mut self) {
        self.clear_nodedata();
        self.clear_networkdata();
        self.clear_servicedata();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeeData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeeData {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FeeSchedule {
    // message fields
    pub transactionFeeSchedule: ::protobuf::RepeatedField<TransactionFeeSchedule>,
    pub feeScheduleValidityDuration: ::protobuf::SingularPtrField<super::Duration::Duration>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl FeeSchedule {
    pub fn new() -> FeeSchedule {
        ::std::default::Default::default()
    }

    // repeated .proto.TransactionFeeSchedule transactionFeeSchedule = 1;

    pub fn clear_transactionFeeSchedule(&mut self) {
        self.transactionFeeSchedule.clear();
    }

    // Param is passed by value, moved
    pub fn set_transactionFeeSchedule(&mut self, v: ::protobuf::RepeatedField<TransactionFeeSchedule>) {
        self.transactionFeeSchedule = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transactionFeeSchedule(&mut self) -> &mut ::protobuf::RepeatedField<TransactionFeeSchedule> {
        &mut self.transactionFeeSchedule
    }

    // Take field
    pub fn take_transactionFeeSchedule(&mut self) -> ::protobuf::RepeatedField<TransactionFeeSchedule> {
        ::std::mem::replace(&mut self.transactionFeeSchedule, ::protobuf::RepeatedField::new())
    }

    pub fn get_transactionFeeSchedule(&self) -> &[TransactionFeeSchedule] {
        &self.transactionFeeSchedule
    }

    // .proto.Duration feeScheduleValidityDuration = 2;

    pub fn clear_feeScheduleValidityDuration(&mut self) {
        self.feeScheduleValidityDuration.clear();
    }

    pub fn has_feeScheduleValidityDuration(&self) -> bool {
        self.feeScheduleValidityDuration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feeScheduleValidityDuration(&mut self, v: super::Duration::Duration) {
        self.feeScheduleValidityDuration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_feeScheduleValidityDuration(&mut self) -> &mut super::Duration::Duration {
        if self.feeScheduleValidityDuration.is_none() {
            self.feeScheduleValidityDuration.set_default();
        }
        self.feeScheduleValidityDuration.as_mut().unwrap()
    }

    // Take field
    pub fn take_feeScheduleValidityDuration(&mut self) -> super::Duration::Duration {
        self.feeScheduleValidityDuration.take().unwrap_or_else(|| super::Duration::Duration::new())
    }

    pub fn get_feeScheduleValidityDuration(&self) -> &super::Duration::Duration {
        self.feeScheduleValidityDuration.as_ref().unwrap_or_else(|| super::Duration::Duration::default_instance())
    }
}

impl ::protobuf::Message for FeeSchedule {
    fn is_initialized(&self) -> bool {
        for v in &self.transactionFeeSchedule {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.feeScheduleValidityDuration {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transactionFeeSchedule)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.feeScheduleValidityDuration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.transactionFeeSchedule {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.feeScheduleValidityDuration.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.transactionFeeSchedule {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.feeScheduleValidityDuration.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FeeSchedule {
        FeeSchedule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TransactionFeeSchedule>>(
                    "transactionFeeSchedule",
                    |m: &FeeSchedule| { &m.transactionFeeSchedule },
                    |m: &mut FeeSchedule| { &mut m.transactionFeeSchedule },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::Duration::Duration>>(
                    "feeScheduleValidityDuration",
                    |m: &FeeSchedule| { &m.feeScheduleValidityDuration },
                    |m: &mut FeeSchedule| { &mut m.feeScheduleValidityDuration },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FeeSchedule>(
                    "FeeSchedule",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FeeSchedule {
        static mut instance: ::protobuf::lazy::Lazy<FeeSchedule> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FeeSchedule,
        };
        unsafe {
            instance.get(FeeSchedule::new)
        }
    }
}

impl ::protobuf::Clear for FeeSchedule {
    fn clear(&mut self) {
        self.clear_transactionFeeSchedule();
        self.clear_feeScheduleValidityDuration();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FeeSchedule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FeeSchedule {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeAddress {
    // message fields
    pub ipAddress: ::std::vec::Vec<u8>,
    pub portno: i32,
    pub memo: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl NodeAddress {
    pub fn new() -> NodeAddress {
        ::std::default::Default::default()
    }

    // bytes ipAddress = 1;

    pub fn clear_ipAddress(&mut self) {
        self.ipAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_ipAddress(&mut self, v: ::std::vec::Vec<u8>) {
        self.ipAddress = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipAddress(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ipAddress
    }

    // Take field
    pub fn take_ipAddress(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ipAddress, ::std::vec::Vec::new())
    }

    pub fn get_ipAddress(&self) -> &[u8] {
        &self.ipAddress
    }

    // int32 portno = 2;

    pub fn clear_portno(&mut self) {
        self.portno = 0;
    }

    // Param is passed by value, moved
    pub fn set_portno(&mut self, v: i32) {
        self.portno = v;
    }

    pub fn get_portno(&self) -> i32 {
        self.portno
    }

    // bytes memo = 3;

    pub fn clear_memo(&mut self) {
        self.memo.clear();
    }

    // Param is passed by value, moved
    pub fn set_memo(&mut self, v: ::std::vec::Vec<u8>) {
        self.memo = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_memo(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.memo
    }

    // Take field
    pub fn take_memo(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.memo, ::std::vec::Vec::new())
    }

    pub fn get_memo(&self) -> &[u8] {
        &self.memo
    }
}

impl ::protobuf::Message for NodeAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ipAddress)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.portno = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.memo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ipAddress.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.ipAddress);
        }
        if self.portno != 0 {
            my_size += ::protobuf::rt::value_size(2, self.portno, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.memo.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.memo);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.ipAddress.is_empty() {
            os.write_bytes(1, &self.ipAddress)?;
        }
        if self.portno != 0 {
            os.write_int32(2, self.portno)?;
        }
        if !self.memo.is_empty() {
            os.write_bytes(3, &self.memo)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeAddress {
        NodeAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ipAddress",
                    |m: &NodeAddress| { &m.ipAddress },
                    |m: &mut NodeAddress| { &mut m.ipAddress },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "portno",
                    |m: &NodeAddress| { &m.portno },
                    |m: &mut NodeAddress| { &mut m.portno },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "memo",
                    |m: &NodeAddress| { &m.memo },
                    |m: &mut NodeAddress| { &mut m.memo },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeAddress>(
                    "NodeAddress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodeAddress {
        static mut instance: ::protobuf::lazy::Lazy<NodeAddress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeAddress,
        };
        unsafe {
            instance.get(NodeAddress::new)
        }
    }
}

impl ::protobuf::Clear for NodeAddress {
    fn clear(&mut self) {
        self.clear_ipAddress();
        self.clear_portno();
        self.clear_memo();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeAddressBook {
    // message fields
    pub nodeAddress: ::protobuf::RepeatedField<NodeAddress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl NodeAddressBook {
    pub fn new() -> NodeAddressBook {
        ::std::default::Default::default()
    }

    // repeated .proto.NodeAddress nodeAddress = 1;

    pub fn clear_nodeAddress(&mut self) {
        self.nodeAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodeAddress(&mut self, v: ::protobuf::RepeatedField<NodeAddress>) {
        self.nodeAddress = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodeAddress(&mut self) -> &mut ::protobuf::RepeatedField<NodeAddress> {
        &mut self.nodeAddress
    }

    // Take field
    pub fn take_nodeAddress(&mut self) -> ::protobuf::RepeatedField<NodeAddress> {
        ::std::mem::replace(&mut self.nodeAddress, ::protobuf::RepeatedField::new())
    }

    pub fn get_nodeAddress(&self) -> &[NodeAddress] {
        &self.nodeAddress
    }
}

impl ::protobuf::Message for NodeAddressBook {
    fn is_initialized(&self) -> bool {
        for v in &self.nodeAddress {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nodeAddress)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.nodeAddress {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        for v in &self.nodeAddress {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeAddressBook {
        NodeAddressBook::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeAddress>>(
                    "nodeAddress",
                    |m: &NodeAddressBook| { &m.nodeAddress },
                    |m: &mut NodeAddressBook| { &mut m.nodeAddress },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<NodeAddressBook>(
                    "NodeAddressBook",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NodeAddressBook {
        static mut instance: ::protobuf::lazy::Lazy<NodeAddressBook> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const NodeAddressBook,
        };
        unsafe {
            instance.get(NodeAddressBook::new)
        }
    }
}

impl ::protobuf::Clear for NodeAddressBook {
    fn clear(&mut self) {
        self.clear_nodeAddress();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeAddressBook {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeAddressBook {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum HederaFunctionality {
    CryptoCreate = 0,
    CryptoTransfer = 1,
    CryptoUpdate = 2,
    CryptoDelete = 3,
    CryptoAddClaim = 4,
    CryptoDeleteClaim = 5,
    ContractCall = 6,
    ContractCreate = 7,
    ContractUpdate = 8,
    FileCreate = 9,
    FileAppend = 10,
    FileUpdate = 11,
    FileDelete = 12,
    CryptoGetAccountBalance = 13,
    CryptoGetAccountRecords = 14,
    CryptoGetInfo = 15,
    ContractCallLocal = 16,
    ContractGetInfo = 17,
    ContractGetBytecode = 18,
    GetBySolidityID = 19,
    GetByKey = 20,
    CryptoGetClaim = 21,
    CryptoGetStakers = 22,
    FileGetContents = 23,
    FileGetInfo = 24,
    TransactionGetRecord = 25,
    ContractGetRecords = 26,
}

impl ::protobuf::ProtobufEnum for HederaFunctionality {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HederaFunctionality> {
        match value {
            0 => ::std::option::Option::Some(HederaFunctionality::CryptoCreate),
            1 => ::std::option::Option::Some(HederaFunctionality::CryptoTransfer),
            2 => ::std::option::Option::Some(HederaFunctionality::CryptoUpdate),
            3 => ::std::option::Option::Some(HederaFunctionality::CryptoDelete),
            4 => ::std::option::Option::Some(HederaFunctionality::CryptoAddClaim),
            5 => ::std::option::Option::Some(HederaFunctionality::CryptoDeleteClaim),
            6 => ::std::option::Option::Some(HederaFunctionality::ContractCall),
            7 => ::std::option::Option::Some(HederaFunctionality::ContractCreate),
            8 => ::std::option::Option::Some(HederaFunctionality::ContractUpdate),
            9 => ::std::option::Option::Some(HederaFunctionality::FileCreate),
            10 => ::std::option::Option::Some(HederaFunctionality::FileAppend),
            11 => ::std::option::Option::Some(HederaFunctionality::FileUpdate),
            12 => ::std::option::Option::Some(HederaFunctionality::FileDelete),
            13 => ::std::option::Option::Some(HederaFunctionality::CryptoGetAccountBalance),
            14 => ::std::option::Option::Some(HederaFunctionality::CryptoGetAccountRecords),
            15 => ::std::option::Option::Some(HederaFunctionality::CryptoGetInfo),
            16 => ::std::option::Option::Some(HederaFunctionality::ContractCallLocal),
            17 => ::std::option::Option::Some(HederaFunctionality::ContractGetInfo),
            18 => ::std::option::Option::Some(HederaFunctionality::ContractGetBytecode),
            19 => ::std::option::Option::Some(HederaFunctionality::GetBySolidityID),
            20 => ::std::option::Option::Some(HederaFunctionality::GetByKey),
            21 => ::std::option::Option::Some(HederaFunctionality::CryptoGetClaim),
            22 => ::std::option::Option::Some(HederaFunctionality::CryptoGetStakers),
            23 => ::std::option::Option::Some(HederaFunctionality::FileGetContents),
            24 => ::std::option::Option::Some(HederaFunctionality::FileGetInfo),
            25 => ::std::option::Option::Some(HederaFunctionality::TransactionGetRecord),
            26 => ::std::option::Option::Some(HederaFunctionality::ContractGetRecords),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [HederaFunctionality] = &[
            HederaFunctionality::CryptoCreate,
            HederaFunctionality::CryptoTransfer,
            HederaFunctionality::CryptoUpdate,
            HederaFunctionality::CryptoDelete,
            HederaFunctionality::CryptoAddClaim,
            HederaFunctionality::CryptoDeleteClaim,
            HederaFunctionality::ContractCall,
            HederaFunctionality::ContractCreate,
            HederaFunctionality::ContractUpdate,
            HederaFunctionality::FileCreate,
            HederaFunctionality::FileAppend,
            HederaFunctionality::FileUpdate,
            HederaFunctionality::FileDelete,
            HederaFunctionality::CryptoGetAccountBalance,
            HederaFunctionality::CryptoGetAccountRecords,
            HederaFunctionality::CryptoGetInfo,
            HederaFunctionality::ContractCallLocal,
            HederaFunctionality::ContractGetInfo,
            HederaFunctionality::ContractGetBytecode,
            HederaFunctionality::GetBySolidityID,
            HederaFunctionality::GetByKey,
            HederaFunctionality::CryptoGetClaim,
            HederaFunctionality::CryptoGetStakers,
            HederaFunctionality::FileGetContents,
            HederaFunctionality::FileGetInfo,
            HederaFunctionality::TransactionGetRecord,
            HederaFunctionality::ContractGetRecords,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("HederaFunctionality", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for HederaFunctionality {
}

impl ::std::default::Default for HederaFunctionality {
    fn default() -> Self {
        HederaFunctionality::CryptoCreate
    }
}

impl ::protobuf::reflect::ProtobufValue for HederaFunctionality {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x10BasicTypes.proto\x12\x05proto\x1a\x0fTimestamp.proto\x1a\x0eDurati\
    on.proto\"%\n\x07ShardID\x12\x1a\n\x08shardNum\x18\x01\x20\x01(\x03R\x08\
    shardNum\"A\n\x07RealmID\x12\x1a\n\x08shardNum\x18\x01\x20\x01(\x03R\x08\
    shardNum\x12\x1a\n\x08realmNum\x18\x02\x20\x01(\x03R\x08realmNum\"c\n\tA\
    ccountID\x12\x1a\n\x08shardNum\x18\x01\x20\x01(\x03R\x08shardNum\x12\x1a\
    \n\x08realmNum\x18\x02\x20\x01(\x03R\x08realmNum\x12\x1e\n\naccountNum\
    \x18\x03\x20\x01(\x03R\naccountNum\"Z\n\x06FileID\x12\x1a\n\x08shardNum\
    \x18\x01\x20\x01(\x03R\x08shardNum\x12\x1a\n\x08realmNum\x18\x02\x20\x01\
    (\x03R\x08realmNum\x12\x18\n\x07fileNum\x18\x03\x20\x01(\x03R\x07fileNum\
    \"f\n\nContractID\x12\x1a\n\x08shardNum\x18\x01\x20\x01(\x03R\x08shardNu\
    m\x12\x1a\n\x08realmNum\x18\x02\x20\x01(\x03R\x08realmNum\x12\x20\n\x0bc\
    ontractNum\x18\x03\x20\x01(\x03R\x0bcontractNum\"\x87\x01\n\rTransaction\
    ID\x12F\n\x15transactionValidStart\x18\x01\x20\x01(\x0b2\x10.proto.Times\
    tampR\x15transactionValidStart\x12.\n\taccountID\x18\x02\x20\x01(\x0b2\
    \x10.proto.AccountIDR\taccountID\"\x80\x02\n\x03Key\x123\n\ncontractID\
    \x18\x01\x20\x01(\x0b2\x11.proto.ContractIDH\0R\ncontractID\x12\x1a\n\
    \x07ed25519\x18\x02\x20\x01(\x0cH\0R\x07ed25519\x12\x1b\n\x08RSA_3072\
    \x18\x03\x20\x01(\x0cH\0R\x07RSA3072\x12\x1d\n\tECDSA_384\x18\x04\x20\
    \x01(\x0cH\0R\x08ECDSA384\x129\n\x0cthresholdKey\x18\x05\x20\x01(\x0b2\
    \x13.proto.ThresholdKeyH\0R\x0cthresholdKey\x12*\n\x07keyList\x18\x06\
    \x20\x01(\x0b2\x0e.proto.KeyListH\0R\x07keyListB\x05\n\x03key\"P\n\x0cTh\
    resholdKey\x12\x1c\n\tthreshold\x18\x01\x20\x01(\rR\tthreshold\x12\"\n\
    \x04keys\x18\x02\x20\x01(\x0b2\x0e.proto.KeyListR\x04keys\")\n\x07KeyLis\
    t\x12\x1e\n\x04keys\x18\x01\x20\x03(\x0b2\n.proto.KeyR\x04keys\"\x99\x02\
    \n\tSignature\x12\x1c\n\x08contract\x18\x01\x20\x01(\x0cH\0R\x08contract\
    \x12\x1a\n\x07ed25519\x18\x02\x20\x01(\x0cH\0R\x07ed25519\x12\x1b\n\x08R\
    SA_3072\x18\x03\x20\x01(\x0cH\0R\x07RSA3072\x12\x1d\n\tECDSA_384\x18\x04\
    \x20\x01(\x0cH\0R\x08ECDSA384\x12K\n\x12thresholdSignature\x18\x05\x20\
    \x01(\x0b2\x19.proto.ThresholdSignatureH\0R\x12thresholdSignature\x12<\n\
    \rsignatureList\x18\x06\x20\x01(\x0b2\x14.proto.SignatureListH\0R\rsigna\
    tureListB\x0b\n\tsignature\">\n\x12ThresholdSignature\x12(\n\x04sigs\x18\
    \x02\x20\x01(\x0b2\x14.proto.SignatureListR\x04sigs\"5\n\rSignatureList\
    \x12$\n\x04sigs\x18\x02\x20\x03(\x0b2\x10.proto.SignatureR\x04sigs\"\xdf\
    \x01\n\rFeeComponents\x12\x10\n\x03min\x18\x01\x20\x01(\x03R\x03min\x12\
    \x10\n\x03max\x18\x02\x20\x01(\x03R\x03max\x12\x1a\n\x08constant\x18\x03\
    \x20\x01(\x03R\x08constant\x12\x10\n\x03bpt\x18\x04\x20\x01(\x03R\x03bpt\
    \x12\x10\n\x03vpt\x18\x05\x20\x01(\x03R\x03vpt\x12\x10\n\x03rbs\x18\x06\
    \x20\x01(\x03R\x03rbs\x12\x10\n\x03sbs\x18\x07\x20\x01(\x03R\x03sbs\x12\
    \x10\n\x03gas\x18\x08\x20\x01(\x03R\x03gas\x12\x0e\n\x02tv\x18\t\x20\x01\
    (\x03R\x02tv\x12\x10\n\x03bpr\x18\n\x20\x01(\x03R\x03bpr\x12\x12\n\x04sb\
    pr\x18\x0b\x20\x01(\x03R\x04sbpr\"\x90\x01\n\x16TransactionFeeSchedule\
    \x12L\n\x13hederaFunctionality\x18\x01\x20\x01(\x0e2\x1a.proto.HederaFun\
    ctionalityR\x13hederaFunctionality\x12(\n\x07feeData\x18\x02\x20\x01(\
    \x0b2\x0e.proto.FeeDataR\x07feeData\"\xab\x01\n\x07FeeData\x120\n\x08nod\
    edata\x18\x01\x20\x01(\x0b2\x14.proto.FeeComponentsR\x08nodedata\x126\n\
    \x0bnetworkdata\x18\x02\x20\x01(\x0b2\x14.proto.FeeComponentsR\x0bnetwor\
    kdata\x126\n\x0bservicedata\x18\x03\x20\x01(\x0b2\x14.proto.FeeComponent\
    sR\x0bservicedata\"\xb7\x01\n\x0bFeeSchedule\x12U\n\x16transactionFeeSch\
    edule\x18\x01\x20\x03(\x0b2\x1d.proto.TransactionFeeScheduleR\x16transac\
    tionFeeSchedule\x12Q\n\x1bfeeScheduleValidityDuration\x18\x02\x20\x01(\
    \x0b2\x0f.proto.DurationR\x1bfeeScheduleValidityDuration\"W\n\x0bNodeAdd\
    ress\x12\x1c\n\tipAddress\x18\x01\x20\x01(\x0cR\tipAddress\x12\x16\n\x06\
    portno\x18\x02\x20\x01(\x05R\x06portno\x12\x12\n\x04memo\x18\x03\x20\x01\
    (\x0cR\x04memo\"G\n\x0fNodeAddressBook\x124\n\x0bnodeAddress\x18\x01\x20\
    \x03(\x0b2\x12.proto.NodeAddressR\x0bnodeAddress*\xbb\x04\n\x13HederaFun\
    ctionality\x12\x10\n\x0cCryptoCreate\x10\0\x12\x12\n\x0eCryptoTransfer\
    \x10\x01\x12\x10\n\x0cCryptoUpdate\x10\x02\x12\x10\n\x0cCryptoDelete\x10\
    \x03\x12\x12\n\x0eCryptoAddClaim\x10\x04\x12\x15\n\x11CryptoDeleteClaim\
    \x10\x05\x12\x10\n\x0cContractCall\x10\x06\x12\x12\n\x0eContractCreate\
    \x10\x07\x12\x12\n\x0eContractUpdate\x10\x08\x12\x0e\n\nFileCreate\x10\t\
    \x12\x0e\n\nFileAppend\x10\n\x12\x0e\n\nFileUpdate\x10\x0b\x12\x0e\n\nFi\
    leDelete\x10\x0c\x12\x1b\n\x17CryptoGetAccountBalance\x10\r\x12\x1b\n\
    \x17CryptoGetAccountRecords\x10\x0e\x12\x11\n\rCryptoGetInfo\x10\x0f\x12\
    \x15\n\x11ContractCallLocal\x10\x10\x12\x13\n\x0fContractGetInfo\x10\x11\
    \x12\x17\n\x13ContractGetBytecode\x10\x12\x12\x13\n\x0fGetBySolidityID\
    \x10\x13\x12\x0c\n\x08GetByKey\x10\x14\x12\x12\n\x0eCryptoGetClaim\x10\
    \x15\x12\x14\n\x10CryptoGetStakers\x10\x16\x12\x13\n\x0fFileGetContents\
    \x10\x17\x12\x0f\n\x0bFileGetInfo\x10\x18\x12\x18\n\x14TransactionGetRec\
    ord\x10\x19\x12\x16\n\x12ContractGetRecords\x10\x1aB&\n\"com.hederahashg\
    raph.api.proto.javaP\x01b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
