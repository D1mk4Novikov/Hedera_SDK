// This file is generated by rust-protobuf 2.3.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct Query {
    // message oneof groups
    pub query: ::std::option::Option<Query_oneof_query>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Query_oneof_query {
    getByKey(super::GetByKey::GetByKeyQuery),
    getBySolidityID(super::GetBySolidityID::GetBySolidityIDQuery),
    contractCallLocal(super::ContractCallLocal::ContractCallLocalQuery),
    contractGetInfo(super::ContractGetInfo::ContractGetInfoQuery),
    contractGetBytecode(super::ContractGetBytecode::ContractGetBytecodeQuery),
    ContractGetRecords(super::ContractGetRecords::ContractGetRecordsQuery),
    cryptogetAccountBalance(super::CryptoGetAccountBalance::CryptoGetAccountBalanceQuery),
    cryptoGetAccountRecords(super::CryptoGetAccountRecords::CryptoGetAccountRecordsQuery),
    cryptoGetInfo(super::CryptoGetInfo::CryptoGetInfoQuery),
    cryptoGetClaim(super::CryptoGetClaim::CryptoGetClaimQuery),
    cryptoGetProxyStakers(super::CryptoGetStakers::CryptoGetStakersQuery),
    fileGetContents(super::FileGetContents::FileGetContentsQuery),
    fileGetInfo(super::FileGetInfo::FileGetInfoQuery),
    transactionGetReceipt(super::TransactionGetReceipt::TransactionGetReceiptQuery),
    transactionGetRecord(super::TransactionGetRecord::TransactionGetRecordQuery),
    transactionGetFastRecord(super::TransactionGetFastRecord::TransactionGetFastRecordQuery),
}

impl Query {
    pub fn new() -> Query {
        ::std::default::Default::default()
    }

    // .proto.GetByKeyQuery getByKey = 1;

    pub fn clear_getByKey(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_getByKey(&self) -> bool {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::getByKey(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getByKey(&mut self, v: super::GetByKey::GetByKeyQuery) {
        self.query = ::std::option::Option::Some(Query_oneof_query::getByKey(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getByKey(&mut self) -> &mut super::GetByKey::GetByKeyQuery {
        if let ::std::option::Option::Some(Query_oneof_query::getByKey(_)) = self.query {
        } else {
            self.query = ::std::option::Option::Some(Query_oneof_query::getByKey(super::GetByKey::GetByKeyQuery::new()));
        }
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::getByKey(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getByKey(&mut self) -> super::GetByKey::GetByKeyQuery {
        if self.has_getByKey() {
            match self.query.take() {
                ::std::option::Option::Some(Query_oneof_query::getByKey(v)) => v,
                _ => panic!(),
            }
        } else {
            super::GetByKey::GetByKeyQuery::new()
        }
    }

    pub fn get_getByKey(&self) -> &super::GetByKey::GetByKeyQuery {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::getByKey(ref v)) => v,
            _ => super::GetByKey::GetByKeyQuery::default_instance(),
        }
    }

    // .proto.GetBySolidityIDQuery getBySolidityID = 2;

    pub fn clear_getBySolidityID(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_getBySolidityID(&self) -> bool {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::getBySolidityID(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getBySolidityID(&mut self, v: super::GetBySolidityID::GetBySolidityIDQuery) {
        self.query = ::std::option::Option::Some(Query_oneof_query::getBySolidityID(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getBySolidityID(&mut self) -> &mut super::GetBySolidityID::GetBySolidityIDQuery {
        if let ::std::option::Option::Some(Query_oneof_query::getBySolidityID(_)) = self.query {
        } else {
            self.query = ::std::option::Option::Some(Query_oneof_query::getBySolidityID(super::GetBySolidityID::GetBySolidityIDQuery::new()));
        }
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::getBySolidityID(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getBySolidityID(&mut self) -> super::GetBySolidityID::GetBySolidityIDQuery {
        if self.has_getBySolidityID() {
            match self.query.take() {
                ::std::option::Option::Some(Query_oneof_query::getBySolidityID(v)) => v,
                _ => panic!(),
            }
        } else {
            super::GetBySolidityID::GetBySolidityIDQuery::new()
        }
    }

    pub fn get_getBySolidityID(&self) -> &super::GetBySolidityID::GetBySolidityIDQuery {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::getBySolidityID(ref v)) => v,
            _ => super::GetBySolidityID::GetBySolidityIDQuery::default_instance(),
        }
    }

    // .proto.ContractCallLocalQuery contractCallLocal = 3;

    pub fn clear_contractCallLocal(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_contractCallLocal(&self) -> bool {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::contractCallLocal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contractCallLocal(&mut self, v: super::ContractCallLocal::ContractCallLocalQuery) {
        self.query = ::std::option::Option::Some(Query_oneof_query::contractCallLocal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contractCallLocal(&mut self) -> &mut super::ContractCallLocal::ContractCallLocalQuery {
        if let ::std::option::Option::Some(Query_oneof_query::contractCallLocal(_)) = self.query {
        } else {
            self.query = ::std::option::Option::Some(Query_oneof_query::contractCallLocal(super::ContractCallLocal::ContractCallLocalQuery::new()));
        }
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::contractCallLocal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contractCallLocal(&mut self) -> super::ContractCallLocal::ContractCallLocalQuery {
        if self.has_contractCallLocal() {
            match self.query.take() {
                ::std::option::Option::Some(Query_oneof_query::contractCallLocal(v)) => v,
                _ => panic!(),
            }
        } else {
            super::ContractCallLocal::ContractCallLocalQuery::new()
        }
    }

    pub fn get_contractCallLocal(&self) -> &super::ContractCallLocal::ContractCallLocalQuery {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::contractCallLocal(ref v)) => v,
            _ => super::ContractCallLocal::ContractCallLocalQuery::default_instance(),
        }
    }

    // .proto.ContractGetInfoQuery contractGetInfo = 4;

    pub fn clear_contractGetInfo(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_contractGetInfo(&self) -> bool {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::contractGetInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contractGetInfo(&mut self, v: super::ContractGetInfo::ContractGetInfoQuery) {
        self.query = ::std::option::Option::Some(Query_oneof_query::contractGetInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contractGetInfo(&mut self) -> &mut super::ContractGetInfo::ContractGetInfoQuery {
        if let ::std::option::Option::Some(Query_oneof_query::contractGetInfo(_)) = self.query {
        } else {
            self.query = ::std::option::Option::Some(Query_oneof_query::contractGetInfo(super::ContractGetInfo::ContractGetInfoQuery::new()));
        }
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::contractGetInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contractGetInfo(&mut self) -> super::ContractGetInfo::ContractGetInfoQuery {
        if self.has_contractGetInfo() {
            match self.query.take() {
                ::std::option::Option::Some(Query_oneof_query::contractGetInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            super::ContractGetInfo::ContractGetInfoQuery::new()
        }
    }

    pub fn get_contractGetInfo(&self) -> &super::ContractGetInfo::ContractGetInfoQuery {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::contractGetInfo(ref v)) => v,
            _ => super::ContractGetInfo::ContractGetInfoQuery::default_instance(),
        }
    }

    // .proto.ContractGetBytecodeQuery contractGetBytecode = 5;

    pub fn clear_contractGetBytecode(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_contractGetBytecode(&self) -> bool {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::contractGetBytecode(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contractGetBytecode(&mut self, v: super::ContractGetBytecode::ContractGetBytecodeQuery) {
        self.query = ::std::option::Option::Some(Query_oneof_query::contractGetBytecode(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contractGetBytecode(&mut self) -> &mut super::ContractGetBytecode::ContractGetBytecodeQuery {
        if let ::std::option::Option::Some(Query_oneof_query::contractGetBytecode(_)) = self.query {
        } else {
            self.query = ::std::option::Option::Some(Query_oneof_query::contractGetBytecode(super::ContractGetBytecode::ContractGetBytecodeQuery::new()));
        }
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::contractGetBytecode(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contractGetBytecode(&mut self) -> super::ContractGetBytecode::ContractGetBytecodeQuery {
        if self.has_contractGetBytecode() {
            match self.query.take() {
                ::std::option::Option::Some(Query_oneof_query::contractGetBytecode(v)) => v,
                _ => panic!(),
            }
        } else {
            super::ContractGetBytecode::ContractGetBytecodeQuery::new()
        }
    }

    pub fn get_contractGetBytecode(&self) -> &super::ContractGetBytecode::ContractGetBytecodeQuery {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::contractGetBytecode(ref v)) => v,
            _ => super::ContractGetBytecode::ContractGetBytecodeQuery::default_instance(),
        }
    }

    // .proto.ContractGetRecordsQuery ContractGetRecords = 6;

    pub fn clear_ContractGetRecords(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_ContractGetRecords(&self) -> bool {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::ContractGetRecords(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ContractGetRecords(&mut self, v: super::ContractGetRecords::ContractGetRecordsQuery) {
        self.query = ::std::option::Option::Some(Query_oneof_query::ContractGetRecords(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ContractGetRecords(&mut self) -> &mut super::ContractGetRecords::ContractGetRecordsQuery {
        if let ::std::option::Option::Some(Query_oneof_query::ContractGetRecords(_)) = self.query {
        } else {
            self.query = ::std::option::Option::Some(Query_oneof_query::ContractGetRecords(super::ContractGetRecords::ContractGetRecordsQuery::new()));
        }
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::ContractGetRecords(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ContractGetRecords(&mut self) -> super::ContractGetRecords::ContractGetRecordsQuery {
        if self.has_ContractGetRecords() {
            match self.query.take() {
                ::std::option::Option::Some(Query_oneof_query::ContractGetRecords(v)) => v,
                _ => panic!(),
            }
        } else {
            super::ContractGetRecords::ContractGetRecordsQuery::new()
        }
    }

    pub fn get_ContractGetRecords(&self) -> &super::ContractGetRecords::ContractGetRecordsQuery {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::ContractGetRecords(ref v)) => v,
            _ => super::ContractGetRecords::ContractGetRecordsQuery::default_instance(),
        }
    }

    // .proto.CryptoGetAccountBalanceQuery cryptogetAccountBalance = 7;

    pub fn clear_cryptogetAccountBalance(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_cryptogetAccountBalance(&self) -> bool {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::cryptogetAccountBalance(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cryptogetAccountBalance(&mut self, v: super::CryptoGetAccountBalance::CryptoGetAccountBalanceQuery) {
        self.query = ::std::option::Option::Some(Query_oneof_query::cryptogetAccountBalance(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cryptogetAccountBalance(&mut self) -> &mut super::CryptoGetAccountBalance::CryptoGetAccountBalanceQuery {
        if let ::std::option::Option::Some(Query_oneof_query::cryptogetAccountBalance(_)) = self.query {
        } else {
            self.query = ::std::option::Option::Some(Query_oneof_query::cryptogetAccountBalance(super::CryptoGetAccountBalance::CryptoGetAccountBalanceQuery::new()));
        }
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::cryptogetAccountBalance(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cryptogetAccountBalance(&mut self) -> super::CryptoGetAccountBalance::CryptoGetAccountBalanceQuery {
        if self.has_cryptogetAccountBalance() {
            match self.query.take() {
                ::std::option::Option::Some(Query_oneof_query::cryptogetAccountBalance(v)) => v,
                _ => panic!(),
            }
        } else {
            super::CryptoGetAccountBalance::CryptoGetAccountBalanceQuery::new()
        }
    }

    pub fn get_cryptogetAccountBalance(&self) -> &super::CryptoGetAccountBalance::CryptoGetAccountBalanceQuery {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::cryptogetAccountBalance(ref v)) => v,
            _ => super::CryptoGetAccountBalance::CryptoGetAccountBalanceQuery::default_instance(),
        }
    }

    // .proto.CryptoGetAccountRecordsQuery cryptoGetAccountRecords = 8;

    pub fn clear_cryptoGetAccountRecords(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_cryptoGetAccountRecords(&self) -> bool {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::cryptoGetAccountRecords(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cryptoGetAccountRecords(&mut self, v: super::CryptoGetAccountRecords::CryptoGetAccountRecordsQuery) {
        self.query = ::std::option::Option::Some(Query_oneof_query::cryptoGetAccountRecords(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cryptoGetAccountRecords(&mut self) -> &mut super::CryptoGetAccountRecords::CryptoGetAccountRecordsQuery {
        if let ::std::option::Option::Some(Query_oneof_query::cryptoGetAccountRecords(_)) = self.query {
        } else {
            self.query = ::std::option::Option::Some(Query_oneof_query::cryptoGetAccountRecords(super::CryptoGetAccountRecords::CryptoGetAccountRecordsQuery::new()));
        }
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::cryptoGetAccountRecords(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cryptoGetAccountRecords(&mut self) -> super::CryptoGetAccountRecords::CryptoGetAccountRecordsQuery {
        if self.has_cryptoGetAccountRecords() {
            match self.query.take() {
                ::std::option::Option::Some(Query_oneof_query::cryptoGetAccountRecords(v)) => v,
                _ => panic!(),
            }
        } else {
            super::CryptoGetAccountRecords::CryptoGetAccountRecordsQuery::new()
        }
    }

    pub fn get_cryptoGetAccountRecords(&self) -> &super::CryptoGetAccountRecords::CryptoGetAccountRecordsQuery {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::cryptoGetAccountRecords(ref v)) => v,
            _ => super::CryptoGetAccountRecords::CryptoGetAccountRecordsQuery::default_instance(),
        }
    }

    // .proto.CryptoGetInfoQuery cryptoGetInfo = 9;

    pub fn clear_cryptoGetInfo(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_cryptoGetInfo(&self) -> bool {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::cryptoGetInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cryptoGetInfo(&mut self, v: super::CryptoGetInfo::CryptoGetInfoQuery) {
        self.query = ::std::option::Option::Some(Query_oneof_query::cryptoGetInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cryptoGetInfo(&mut self) -> &mut super::CryptoGetInfo::CryptoGetInfoQuery {
        if let ::std::option::Option::Some(Query_oneof_query::cryptoGetInfo(_)) = self.query {
        } else {
            self.query = ::std::option::Option::Some(Query_oneof_query::cryptoGetInfo(super::CryptoGetInfo::CryptoGetInfoQuery::new()));
        }
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::cryptoGetInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cryptoGetInfo(&mut self) -> super::CryptoGetInfo::CryptoGetInfoQuery {
        if self.has_cryptoGetInfo() {
            match self.query.take() {
                ::std::option::Option::Some(Query_oneof_query::cryptoGetInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            super::CryptoGetInfo::CryptoGetInfoQuery::new()
        }
    }

    pub fn get_cryptoGetInfo(&self) -> &super::CryptoGetInfo::CryptoGetInfoQuery {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::cryptoGetInfo(ref v)) => v,
            _ => super::CryptoGetInfo::CryptoGetInfoQuery::default_instance(),
        }
    }

    // .proto.CryptoGetClaimQuery cryptoGetClaim = 10;

    pub fn clear_cryptoGetClaim(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_cryptoGetClaim(&self) -> bool {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::cryptoGetClaim(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cryptoGetClaim(&mut self, v: super::CryptoGetClaim::CryptoGetClaimQuery) {
        self.query = ::std::option::Option::Some(Query_oneof_query::cryptoGetClaim(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cryptoGetClaim(&mut self) -> &mut super::CryptoGetClaim::CryptoGetClaimQuery {
        if let ::std::option::Option::Some(Query_oneof_query::cryptoGetClaim(_)) = self.query {
        } else {
            self.query = ::std::option::Option::Some(Query_oneof_query::cryptoGetClaim(super::CryptoGetClaim::CryptoGetClaimQuery::new()));
        }
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::cryptoGetClaim(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cryptoGetClaim(&mut self) -> super::CryptoGetClaim::CryptoGetClaimQuery {
        if self.has_cryptoGetClaim() {
            match self.query.take() {
                ::std::option::Option::Some(Query_oneof_query::cryptoGetClaim(v)) => v,
                _ => panic!(),
            }
        } else {
            super::CryptoGetClaim::CryptoGetClaimQuery::new()
        }
    }

    pub fn get_cryptoGetClaim(&self) -> &super::CryptoGetClaim::CryptoGetClaimQuery {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::cryptoGetClaim(ref v)) => v,
            _ => super::CryptoGetClaim::CryptoGetClaimQuery::default_instance(),
        }
    }

    // .proto.CryptoGetStakersQuery cryptoGetProxyStakers = 11;

    pub fn clear_cryptoGetProxyStakers(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_cryptoGetProxyStakers(&self) -> bool {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::cryptoGetProxyStakers(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cryptoGetProxyStakers(&mut self, v: super::CryptoGetStakers::CryptoGetStakersQuery) {
        self.query = ::std::option::Option::Some(Query_oneof_query::cryptoGetProxyStakers(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cryptoGetProxyStakers(&mut self) -> &mut super::CryptoGetStakers::CryptoGetStakersQuery {
        if let ::std::option::Option::Some(Query_oneof_query::cryptoGetProxyStakers(_)) = self.query {
        } else {
            self.query = ::std::option::Option::Some(Query_oneof_query::cryptoGetProxyStakers(super::CryptoGetStakers::CryptoGetStakersQuery::new()));
        }
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::cryptoGetProxyStakers(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cryptoGetProxyStakers(&mut self) -> super::CryptoGetStakers::CryptoGetStakersQuery {
        if self.has_cryptoGetProxyStakers() {
            match self.query.take() {
                ::std::option::Option::Some(Query_oneof_query::cryptoGetProxyStakers(v)) => v,
                _ => panic!(),
            }
        } else {
            super::CryptoGetStakers::CryptoGetStakersQuery::new()
        }
    }

    pub fn get_cryptoGetProxyStakers(&self) -> &super::CryptoGetStakers::CryptoGetStakersQuery {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::cryptoGetProxyStakers(ref v)) => v,
            _ => super::CryptoGetStakers::CryptoGetStakersQuery::default_instance(),
        }
    }

    // .proto.FileGetContentsQuery fileGetContents = 12;

    pub fn clear_fileGetContents(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_fileGetContents(&self) -> bool {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::fileGetContents(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fileGetContents(&mut self, v: super::FileGetContents::FileGetContentsQuery) {
        self.query = ::std::option::Option::Some(Query_oneof_query::fileGetContents(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fileGetContents(&mut self) -> &mut super::FileGetContents::FileGetContentsQuery {
        if let ::std::option::Option::Some(Query_oneof_query::fileGetContents(_)) = self.query {
        } else {
            self.query = ::std::option::Option::Some(Query_oneof_query::fileGetContents(super::FileGetContents::FileGetContentsQuery::new()));
        }
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::fileGetContents(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fileGetContents(&mut self) -> super::FileGetContents::FileGetContentsQuery {
        if self.has_fileGetContents() {
            match self.query.take() {
                ::std::option::Option::Some(Query_oneof_query::fileGetContents(v)) => v,
                _ => panic!(),
            }
        } else {
            super::FileGetContents::FileGetContentsQuery::new()
        }
    }

    pub fn get_fileGetContents(&self) -> &super::FileGetContents::FileGetContentsQuery {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::fileGetContents(ref v)) => v,
            _ => super::FileGetContents::FileGetContentsQuery::default_instance(),
        }
    }

    // .proto.FileGetInfoQuery fileGetInfo = 13;

    pub fn clear_fileGetInfo(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_fileGetInfo(&self) -> bool {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::fileGetInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fileGetInfo(&mut self, v: super::FileGetInfo::FileGetInfoQuery) {
        self.query = ::std::option::Option::Some(Query_oneof_query::fileGetInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fileGetInfo(&mut self) -> &mut super::FileGetInfo::FileGetInfoQuery {
        if let ::std::option::Option::Some(Query_oneof_query::fileGetInfo(_)) = self.query {
        } else {
            self.query = ::std::option::Option::Some(Query_oneof_query::fileGetInfo(super::FileGetInfo::FileGetInfoQuery::new()));
        }
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::fileGetInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fileGetInfo(&mut self) -> super::FileGetInfo::FileGetInfoQuery {
        if self.has_fileGetInfo() {
            match self.query.take() {
                ::std::option::Option::Some(Query_oneof_query::fileGetInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            super::FileGetInfo::FileGetInfoQuery::new()
        }
    }

    pub fn get_fileGetInfo(&self) -> &super::FileGetInfo::FileGetInfoQuery {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::fileGetInfo(ref v)) => v,
            _ => super::FileGetInfo::FileGetInfoQuery::default_instance(),
        }
    }

    // .proto.TransactionGetReceiptQuery transactionGetReceipt = 14;

    pub fn clear_transactionGetReceipt(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_transactionGetReceipt(&self) -> bool {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::transactionGetReceipt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_transactionGetReceipt(&mut self, v: super::TransactionGetReceipt::TransactionGetReceiptQuery) {
        self.query = ::std::option::Option::Some(Query_oneof_query::transactionGetReceipt(v))
    }

    // Mutable pointer to the field.
    pub fn mut_transactionGetReceipt(&mut self) -> &mut super::TransactionGetReceipt::TransactionGetReceiptQuery {
        if let ::std::option::Option::Some(Query_oneof_query::transactionGetReceipt(_)) = self.query {
        } else {
            self.query = ::std::option::Option::Some(Query_oneof_query::transactionGetReceipt(super::TransactionGetReceipt::TransactionGetReceiptQuery::new()));
        }
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::transactionGetReceipt(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_transactionGetReceipt(&mut self) -> super::TransactionGetReceipt::TransactionGetReceiptQuery {
        if self.has_transactionGetReceipt() {
            match self.query.take() {
                ::std::option::Option::Some(Query_oneof_query::transactionGetReceipt(v)) => v,
                _ => panic!(),
            }
        } else {
            super::TransactionGetReceipt::TransactionGetReceiptQuery::new()
        }
    }

    pub fn get_transactionGetReceipt(&self) -> &super::TransactionGetReceipt::TransactionGetReceiptQuery {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::transactionGetReceipt(ref v)) => v,
            _ => super::TransactionGetReceipt::TransactionGetReceiptQuery::default_instance(),
        }
    }

    // .proto.TransactionGetRecordQuery transactionGetRecord = 15;

    pub fn clear_transactionGetRecord(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_transactionGetRecord(&self) -> bool {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::transactionGetRecord(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_transactionGetRecord(&mut self, v: super::TransactionGetRecord::TransactionGetRecordQuery) {
        self.query = ::std::option::Option::Some(Query_oneof_query::transactionGetRecord(v))
    }

    // Mutable pointer to the field.
    pub fn mut_transactionGetRecord(&mut self) -> &mut super::TransactionGetRecord::TransactionGetRecordQuery {
        if let ::std::option::Option::Some(Query_oneof_query::transactionGetRecord(_)) = self.query {
        } else {
            self.query = ::std::option::Option::Some(Query_oneof_query::transactionGetRecord(super::TransactionGetRecord::TransactionGetRecordQuery::new()));
        }
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::transactionGetRecord(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_transactionGetRecord(&mut self) -> super::TransactionGetRecord::TransactionGetRecordQuery {
        if self.has_transactionGetRecord() {
            match self.query.take() {
                ::std::option::Option::Some(Query_oneof_query::transactionGetRecord(v)) => v,
                _ => panic!(),
            }
        } else {
            super::TransactionGetRecord::TransactionGetRecordQuery::new()
        }
    }

    pub fn get_transactionGetRecord(&self) -> &super::TransactionGetRecord::TransactionGetRecordQuery {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::transactionGetRecord(ref v)) => v,
            _ => super::TransactionGetRecord::TransactionGetRecordQuery::default_instance(),
        }
    }

    // .proto.TransactionGetFastRecordQuery transactionGetFastRecord = 16;

    pub fn clear_transactionGetFastRecord(&mut self) {
        self.query = ::std::option::Option::None;
    }

    pub fn has_transactionGetFastRecord(&self) -> bool {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::transactionGetFastRecord(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_transactionGetFastRecord(&mut self, v: super::TransactionGetFastRecord::TransactionGetFastRecordQuery) {
        self.query = ::std::option::Option::Some(Query_oneof_query::transactionGetFastRecord(v))
    }

    // Mutable pointer to the field.
    pub fn mut_transactionGetFastRecord(&mut self) -> &mut super::TransactionGetFastRecord::TransactionGetFastRecordQuery {
        if let ::std::option::Option::Some(Query_oneof_query::transactionGetFastRecord(_)) = self.query {
        } else {
            self.query = ::std::option::Option::Some(Query_oneof_query::transactionGetFastRecord(super::TransactionGetFastRecord::TransactionGetFastRecordQuery::new()));
        }
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::transactionGetFastRecord(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_transactionGetFastRecord(&mut self) -> super::TransactionGetFastRecord::TransactionGetFastRecordQuery {
        if self.has_transactionGetFastRecord() {
            match self.query.take() {
                ::std::option::Option::Some(Query_oneof_query::transactionGetFastRecord(v)) => v,
                _ => panic!(),
            }
        } else {
            super::TransactionGetFastRecord::TransactionGetFastRecordQuery::new()
        }
    }

    pub fn get_transactionGetFastRecord(&self) -> &super::TransactionGetFastRecord::TransactionGetFastRecordQuery {
        match self.query {
            ::std::option::Option::Some(Query_oneof_query::transactionGetFastRecord(ref v)) => v,
            _ => super::TransactionGetFastRecord::TransactionGetFastRecordQuery::default_instance(),
        }
    }
}

impl ::protobuf::Message for Query {
    fn is_initialized(&self) -> bool {
        if let Some(Query_oneof_query::getByKey(ref v)) = self.query {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Query_oneof_query::getBySolidityID(ref v)) = self.query {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Query_oneof_query::contractCallLocal(ref v)) = self.query {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Query_oneof_query::contractGetInfo(ref v)) = self.query {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Query_oneof_query::contractGetBytecode(ref v)) = self.query {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Query_oneof_query::ContractGetRecords(ref v)) = self.query {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Query_oneof_query::cryptogetAccountBalance(ref v)) = self.query {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Query_oneof_query::cryptoGetAccountRecords(ref v)) = self.query {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Query_oneof_query::cryptoGetInfo(ref v)) = self.query {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Query_oneof_query::cryptoGetClaim(ref v)) = self.query {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Query_oneof_query::cryptoGetProxyStakers(ref v)) = self.query {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Query_oneof_query::fileGetContents(ref v)) = self.query {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Query_oneof_query::fileGetInfo(ref v)) = self.query {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Query_oneof_query::transactionGetReceipt(ref v)) = self.query {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Query_oneof_query::transactionGetRecord(ref v)) = self.query {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Query_oneof_query::transactionGetFastRecord(ref v)) = self.query {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query = ::std::option::Option::Some(Query_oneof_query::getByKey(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query = ::std::option::Option::Some(Query_oneof_query::getBySolidityID(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query = ::std::option::Option::Some(Query_oneof_query::contractCallLocal(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query = ::std::option::Option::Some(Query_oneof_query::contractGetInfo(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query = ::std::option::Option::Some(Query_oneof_query::contractGetBytecode(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query = ::std::option::Option::Some(Query_oneof_query::ContractGetRecords(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query = ::std::option::Option::Some(Query_oneof_query::cryptogetAccountBalance(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query = ::std::option::Option::Some(Query_oneof_query::cryptoGetAccountRecords(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query = ::std::option::Option::Some(Query_oneof_query::cryptoGetInfo(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query = ::std::option::Option::Some(Query_oneof_query::cryptoGetClaim(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query = ::std::option::Option::Some(Query_oneof_query::cryptoGetProxyStakers(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query = ::std::option::Option::Some(Query_oneof_query::fileGetContents(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query = ::std::option::Option::Some(Query_oneof_query::fileGetInfo(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query = ::std::option::Option::Some(Query_oneof_query::transactionGetReceipt(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query = ::std::option::Option::Some(Query_oneof_query::transactionGetRecord(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.query = ::std::option::Option::Some(Query_oneof_query::transactionGetFastRecord(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.query {
            match v {
                &Query_oneof_query::getByKey(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Query_oneof_query::getBySolidityID(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Query_oneof_query::contractCallLocal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Query_oneof_query::contractGetInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Query_oneof_query::contractGetBytecode(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Query_oneof_query::ContractGetRecords(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Query_oneof_query::cryptogetAccountBalance(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Query_oneof_query::cryptoGetAccountRecords(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Query_oneof_query::cryptoGetInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Query_oneof_query::cryptoGetClaim(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Query_oneof_query::cryptoGetProxyStakers(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Query_oneof_query::fileGetContents(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Query_oneof_query::fileGetInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Query_oneof_query::transactionGetReceipt(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Query_oneof_query::transactionGetRecord(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Query_oneof_query::transactionGetFastRecord(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.query {
            match v {
                &Query_oneof_query::getByKey(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Query_oneof_query::getBySolidityID(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Query_oneof_query::contractCallLocal(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Query_oneof_query::contractGetInfo(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Query_oneof_query::contractGetBytecode(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Query_oneof_query::ContractGetRecords(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Query_oneof_query::cryptogetAccountBalance(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Query_oneof_query::cryptoGetAccountRecords(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Query_oneof_query::cryptoGetInfo(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Query_oneof_query::cryptoGetClaim(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Query_oneof_query::cryptoGetProxyStakers(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Query_oneof_query::fileGetContents(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Query_oneof_query::fileGetInfo(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Query_oneof_query::transactionGetReceipt(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Query_oneof_query::transactionGetRecord(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Query_oneof_query::transactionGetFastRecord(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Query {
        Query::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::GetByKey::GetByKeyQuery>(
                    "getByKey",
                    Query::has_getByKey,
                    Query::get_getByKey,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::GetBySolidityID::GetBySolidityIDQuery>(
                    "getBySolidityID",
                    Query::has_getBySolidityID,
                    Query::get_getBySolidityID,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::ContractCallLocal::ContractCallLocalQuery>(
                    "contractCallLocal",
                    Query::has_contractCallLocal,
                    Query::get_contractCallLocal,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::ContractGetInfo::ContractGetInfoQuery>(
                    "contractGetInfo",
                    Query::has_contractGetInfo,
                    Query::get_contractGetInfo,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::ContractGetBytecode::ContractGetBytecodeQuery>(
                    "contractGetBytecode",
                    Query::has_contractGetBytecode,
                    Query::get_contractGetBytecode,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::ContractGetRecords::ContractGetRecordsQuery>(
                    "ContractGetRecords",
                    Query::has_ContractGetRecords,
                    Query::get_ContractGetRecords,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::CryptoGetAccountBalance::CryptoGetAccountBalanceQuery>(
                    "cryptogetAccountBalance",
                    Query::has_cryptogetAccountBalance,
                    Query::get_cryptogetAccountBalance,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::CryptoGetAccountRecords::CryptoGetAccountRecordsQuery>(
                    "cryptoGetAccountRecords",
                    Query::has_cryptoGetAccountRecords,
                    Query::get_cryptoGetAccountRecords,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::CryptoGetInfo::CryptoGetInfoQuery>(
                    "cryptoGetInfo",
                    Query::has_cryptoGetInfo,
                    Query::get_cryptoGetInfo,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::CryptoGetClaim::CryptoGetClaimQuery>(
                    "cryptoGetClaim",
                    Query::has_cryptoGetClaim,
                    Query::get_cryptoGetClaim,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::CryptoGetStakers::CryptoGetStakersQuery>(
                    "cryptoGetProxyStakers",
                    Query::has_cryptoGetProxyStakers,
                    Query::get_cryptoGetProxyStakers,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::FileGetContents::FileGetContentsQuery>(
                    "fileGetContents",
                    Query::has_fileGetContents,
                    Query::get_fileGetContents,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::FileGetInfo::FileGetInfoQuery>(
                    "fileGetInfo",
                    Query::has_fileGetInfo,
                    Query::get_fileGetInfo,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::TransactionGetReceipt::TransactionGetReceiptQuery>(
                    "transactionGetReceipt",
                    Query::has_transactionGetReceipt,
                    Query::get_transactionGetReceipt,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::TransactionGetRecord::TransactionGetRecordQuery>(
                    "transactionGetRecord",
                    Query::has_transactionGetRecord,
                    Query::get_transactionGetRecord,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::TransactionGetFastRecord::TransactionGetFastRecordQuery>(
                    "transactionGetFastRecord",
                    Query::has_transactionGetFastRecord,
                    Query::get_transactionGetFastRecord,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Query>(
                    "Query",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Query {
        static mut instance: ::protobuf::lazy::Lazy<Query> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Query,
        };
        unsafe {
            instance.get(Query::new)
        }
    }
}

impl ::protobuf::Clear for Query {
    fn clear(&mut self) {
        self.clear_getByKey();
        self.clear_getBySolidityID();
        self.clear_contractCallLocal();
        self.clear_contractGetInfo();
        self.clear_contractGetBytecode();
        self.clear_ContractGetRecords();
        self.clear_cryptogetAccountBalance();
        self.clear_cryptoGetAccountRecords();
        self.clear_cryptoGetInfo();
        self.clear_cryptoGetClaim();
        self.clear_cryptoGetProxyStakers();
        self.clear_fileGetContents();
        self.clear_fileGetInfo();
        self.clear_transactionGetReceipt();
        self.clear_transactionGetRecord();
        self.clear_transactionGetFastRecord();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Query {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Query {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0bQuery.proto\x12\x05proto\x1a\x0eGetByKey.proto\x1a\x15GetBySolidit\
    yID.proto\x1a\x17ContractCallLocal.proto\x1a\x15ContractGetInfo.proto\
    \x1a\x19ContractGetBytecode.proto\x1a\x18ContractGetRecords.proto\x1a\
    \x1dCryptoGetAccountBalance.proto\x1a\x1dCryptoGetAccountRecords.proto\
    \x1a\x13CryptoGetInfo.proto\x1a\x14CryptoGetClaim.proto\x1a\x16CryptoGet\
    Stakers.proto\x1a\x15FileGetContents.proto\x1a\x11FileGetInfo.proto\x1a\
    \x1bTransactionGetReceipt.proto\x1a\x1aTransactionGetRecord.proto\x1a\
    \x1eTransactionGetFastRecord.proto\"\x8a\n\n\x05Query\x122\n\x08getByKey\
    \x18\x01\x20\x01(\x0b2\x14.proto.GetByKeyQueryH\0R\x08getByKey\x12G\n\
    \x0fgetBySolidityID\x18\x02\x20\x01(\x0b2\x1b.proto.GetBySolidityIDQuery\
    H\0R\x0fgetBySolidityID\x12M\n\x11contractCallLocal\x18\x03\x20\x01(\x0b\
    2\x1d.proto.ContractCallLocalQueryH\0R\x11contractCallLocal\x12G\n\x0fco\
    ntractGetInfo\x18\x04\x20\x01(\x0b2\x1b.proto.ContractGetInfoQueryH\0R\
    \x0fcontractGetInfo\x12S\n\x13contractGetBytecode\x18\x05\x20\x01(\x0b2\
    \x1f.proto.ContractGetBytecodeQueryH\0R\x13contractGetBytecode\x12P\n\
    \x12ContractGetRecords\x18\x06\x20\x01(\x0b2\x1e.proto.ContractGetRecord\
    sQueryH\0R\x12ContractGetRecords\x12_\n\x17cryptogetAccountBalance\x18\
    \x07\x20\x01(\x0b2#.proto.CryptoGetAccountBalanceQueryH\0R\x17cryptogetA\
    ccountBalance\x12_\n\x17cryptoGetAccountRecords\x18\x08\x20\x01(\x0b2#.p\
    roto.CryptoGetAccountRecordsQueryH\0R\x17cryptoGetAccountRecords\x12A\n\
    \rcryptoGetInfo\x18\t\x20\x01(\x0b2\x19.proto.CryptoGetInfoQueryH\0R\rcr\
    yptoGetInfo\x12D\n\x0ecryptoGetClaim\x18\n\x20\x01(\x0b2\x1a.proto.Crypt\
    oGetClaimQueryH\0R\x0ecryptoGetClaim\x12T\n\x15cryptoGetProxyStakers\x18\
    \x0b\x20\x01(\x0b2\x1c.proto.CryptoGetStakersQueryH\0R\x15cryptoGetProxy\
    Stakers\x12G\n\x0ffileGetContents\x18\x0c\x20\x01(\x0b2\x1b.proto.FileGe\
    tContentsQueryH\0R\x0ffileGetContents\x12;\n\x0bfileGetInfo\x18\r\x20\
    \x01(\x0b2\x17.proto.FileGetInfoQueryH\0R\x0bfileGetInfo\x12Y\n\x15trans\
    actionGetReceipt\x18\x0e\x20\x01(\x0b2!.proto.TransactionGetReceiptQuery\
    H\0R\x15transactionGetReceipt\x12V\n\x14transactionGetRecord\x18\x0f\x20\
    \x01(\x0b2\x20.proto.TransactionGetRecordQueryH\0R\x14transactionGetReco\
    rd\x12b\n\x18transactionGetFastRecord\x18\x10\x20\x01(\x0b2$.proto.Trans\
    actionGetFastRecordQueryH\0R\x18transactionGetFastRecordB\x07\n\x05query\
    B&\n\"com.hederahashgraph.api.proto.javaP\x01b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
