// This file is generated by rust-protobuf 2.3.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct Response {
    // message oneof groups
    pub response: ::std::option::Option<Response_oneof_response>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

#[derive(Clone,PartialEq)]
pub enum Response_oneof_response {
    getByKey(super::GetByKey::GetByKeyResponse),
    getBySolidityID(super::GetBySolidityID::GetBySolidityIDResponse),
    contractCallLocal(super::ContractCallLocal::ContractCallLocalResponse),
    contractGetBytecodeResponse(super::ContractGetBytecode::ContractGetBytecodeResponse),
    contractGetInfo(super::ContractGetInfo::ContractGetInfoResponse),
    contractGetRecordsResponse(super::ContractGetRecords::ContractGetRecordsResponse),
    cryptogetAccountBalance(super::CryptoGetAccountBalance::CryptoGetAccountBalanceResponse),
    cryptoGetAccountRecords(super::CryptoGetAccountRecords::CryptoGetAccountRecordsResponse),
    cryptoGetInfo(super::CryptoGetInfo::CryptoGetInfoResponse),
    cryptoGetClaim(super::CryptoGetClaim::CryptoGetClaimResponse),
    cryptoGetProxyStakers(super::CryptoGetStakers::CryptoGetStakersResponse),
    fileGetContents(super::FileGetContents::FileGetContentsResponse),
    fileGetInfo(super::FileGetInfo::FileGetInfoResponse),
    transactionGetReceipt(super::TransactionGetReceipt::TransactionGetReceiptResponse),
    transactionGetRecord(super::TransactionGetRecord::TransactionGetRecordResponse),
    transactionGetFastRecord(super::TransactionGetFastRecord::TransactionGetFastRecordResponse),
}

impl Response {
    pub fn new() -> Response {
        ::std::default::Default::default()
    }

    // .proto.GetByKeyResponse getByKey = 1;

    pub fn clear_getByKey(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_getByKey(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::getByKey(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getByKey(&mut self, v: super::GetByKey::GetByKeyResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::getByKey(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getByKey(&mut self) -> &mut super::GetByKey::GetByKeyResponse {
        if let ::std::option::Option::Some(Response_oneof_response::getByKey(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::getByKey(super::GetByKey::GetByKeyResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::getByKey(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getByKey(&mut self) -> super::GetByKey::GetByKeyResponse {
        if self.has_getByKey() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::getByKey(v)) => v,
                _ => panic!(),
            }
        } else {
            super::GetByKey::GetByKeyResponse::new()
        }
    }

    pub fn get_getByKey(&self) -> &super::GetByKey::GetByKeyResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::getByKey(ref v)) => v,
            _ => super::GetByKey::GetByKeyResponse::default_instance(),
        }
    }

    // .proto.GetBySolidityIDResponse getBySolidityID = 2;

    pub fn clear_getBySolidityID(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_getBySolidityID(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::getBySolidityID(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_getBySolidityID(&mut self, v: super::GetBySolidityID::GetBySolidityIDResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::getBySolidityID(v))
    }

    // Mutable pointer to the field.
    pub fn mut_getBySolidityID(&mut self) -> &mut super::GetBySolidityID::GetBySolidityIDResponse {
        if let ::std::option::Option::Some(Response_oneof_response::getBySolidityID(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::getBySolidityID(super::GetBySolidityID::GetBySolidityIDResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::getBySolidityID(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_getBySolidityID(&mut self) -> super::GetBySolidityID::GetBySolidityIDResponse {
        if self.has_getBySolidityID() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::getBySolidityID(v)) => v,
                _ => panic!(),
            }
        } else {
            super::GetBySolidityID::GetBySolidityIDResponse::new()
        }
    }

    pub fn get_getBySolidityID(&self) -> &super::GetBySolidityID::GetBySolidityIDResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::getBySolidityID(ref v)) => v,
            _ => super::GetBySolidityID::GetBySolidityIDResponse::default_instance(),
        }
    }

    // .proto.ContractCallLocalResponse contractCallLocal = 3;

    pub fn clear_contractCallLocal(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_contractCallLocal(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::contractCallLocal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contractCallLocal(&mut self, v: super::ContractCallLocal::ContractCallLocalResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::contractCallLocal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contractCallLocal(&mut self) -> &mut super::ContractCallLocal::ContractCallLocalResponse {
        if let ::std::option::Option::Some(Response_oneof_response::contractCallLocal(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::contractCallLocal(super::ContractCallLocal::ContractCallLocalResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::contractCallLocal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contractCallLocal(&mut self) -> super::ContractCallLocal::ContractCallLocalResponse {
        if self.has_contractCallLocal() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::contractCallLocal(v)) => v,
                _ => panic!(),
            }
        } else {
            super::ContractCallLocal::ContractCallLocalResponse::new()
        }
    }

    pub fn get_contractCallLocal(&self) -> &super::ContractCallLocal::ContractCallLocalResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::contractCallLocal(ref v)) => v,
            _ => super::ContractCallLocal::ContractCallLocalResponse::default_instance(),
        }
    }

    // .proto.ContractGetBytecodeResponse contractGetBytecodeResponse = 5;

    pub fn clear_contractGetBytecodeResponse(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_contractGetBytecodeResponse(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::contractGetBytecodeResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contractGetBytecodeResponse(&mut self, v: super::ContractGetBytecode::ContractGetBytecodeResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::contractGetBytecodeResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contractGetBytecodeResponse(&mut self) -> &mut super::ContractGetBytecode::ContractGetBytecodeResponse {
        if let ::std::option::Option::Some(Response_oneof_response::contractGetBytecodeResponse(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::contractGetBytecodeResponse(super::ContractGetBytecode::ContractGetBytecodeResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::contractGetBytecodeResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contractGetBytecodeResponse(&mut self) -> super::ContractGetBytecode::ContractGetBytecodeResponse {
        if self.has_contractGetBytecodeResponse() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::contractGetBytecodeResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            super::ContractGetBytecode::ContractGetBytecodeResponse::new()
        }
    }

    pub fn get_contractGetBytecodeResponse(&self) -> &super::ContractGetBytecode::ContractGetBytecodeResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::contractGetBytecodeResponse(ref v)) => v,
            _ => super::ContractGetBytecode::ContractGetBytecodeResponse::default_instance(),
        }
    }

    // .proto.ContractGetInfoResponse contractGetInfo = 4;

    pub fn clear_contractGetInfo(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_contractGetInfo(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::contractGetInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contractGetInfo(&mut self, v: super::ContractGetInfo::ContractGetInfoResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::contractGetInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contractGetInfo(&mut self) -> &mut super::ContractGetInfo::ContractGetInfoResponse {
        if let ::std::option::Option::Some(Response_oneof_response::contractGetInfo(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::contractGetInfo(super::ContractGetInfo::ContractGetInfoResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::contractGetInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contractGetInfo(&mut self) -> super::ContractGetInfo::ContractGetInfoResponse {
        if self.has_contractGetInfo() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::contractGetInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            super::ContractGetInfo::ContractGetInfoResponse::new()
        }
    }

    pub fn get_contractGetInfo(&self) -> &super::ContractGetInfo::ContractGetInfoResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::contractGetInfo(ref v)) => v,
            _ => super::ContractGetInfo::ContractGetInfoResponse::default_instance(),
        }
    }

    // .proto.ContractGetRecordsResponse contractGetRecordsResponse = 6;

    pub fn clear_contractGetRecordsResponse(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_contractGetRecordsResponse(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::contractGetRecordsResponse(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_contractGetRecordsResponse(&mut self, v: super::ContractGetRecords::ContractGetRecordsResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::contractGetRecordsResponse(v))
    }

    // Mutable pointer to the field.
    pub fn mut_contractGetRecordsResponse(&mut self) -> &mut super::ContractGetRecords::ContractGetRecordsResponse {
        if let ::std::option::Option::Some(Response_oneof_response::contractGetRecordsResponse(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::contractGetRecordsResponse(super::ContractGetRecords::ContractGetRecordsResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::contractGetRecordsResponse(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_contractGetRecordsResponse(&mut self) -> super::ContractGetRecords::ContractGetRecordsResponse {
        if self.has_contractGetRecordsResponse() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::contractGetRecordsResponse(v)) => v,
                _ => panic!(),
            }
        } else {
            super::ContractGetRecords::ContractGetRecordsResponse::new()
        }
    }

    pub fn get_contractGetRecordsResponse(&self) -> &super::ContractGetRecords::ContractGetRecordsResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::contractGetRecordsResponse(ref v)) => v,
            _ => super::ContractGetRecords::ContractGetRecordsResponse::default_instance(),
        }
    }

    // .proto.CryptoGetAccountBalanceResponse cryptogetAccountBalance = 7;

    pub fn clear_cryptogetAccountBalance(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_cryptogetAccountBalance(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::cryptogetAccountBalance(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cryptogetAccountBalance(&mut self, v: super::CryptoGetAccountBalance::CryptoGetAccountBalanceResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::cryptogetAccountBalance(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cryptogetAccountBalance(&mut self) -> &mut super::CryptoGetAccountBalance::CryptoGetAccountBalanceResponse {
        if let ::std::option::Option::Some(Response_oneof_response::cryptogetAccountBalance(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::cryptogetAccountBalance(super::CryptoGetAccountBalance::CryptoGetAccountBalanceResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::cryptogetAccountBalance(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cryptogetAccountBalance(&mut self) -> super::CryptoGetAccountBalance::CryptoGetAccountBalanceResponse {
        if self.has_cryptogetAccountBalance() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::cryptogetAccountBalance(v)) => v,
                _ => panic!(),
            }
        } else {
            super::CryptoGetAccountBalance::CryptoGetAccountBalanceResponse::new()
        }
    }

    pub fn get_cryptogetAccountBalance(&self) -> &super::CryptoGetAccountBalance::CryptoGetAccountBalanceResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::cryptogetAccountBalance(ref v)) => v,
            _ => super::CryptoGetAccountBalance::CryptoGetAccountBalanceResponse::default_instance(),
        }
    }

    // .proto.CryptoGetAccountRecordsResponse cryptoGetAccountRecords = 8;

    pub fn clear_cryptoGetAccountRecords(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_cryptoGetAccountRecords(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::cryptoGetAccountRecords(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cryptoGetAccountRecords(&mut self, v: super::CryptoGetAccountRecords::CryptoGetAccountRecordsResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::cryptoGetAccountRecords(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cryptoGetAccountRecords(&mut self) -> &mut super::CryptoGetAccountRecords::CryptoGetAccountRecordsResponse {
        if let ::std::option::Option::Some(Response_oneof_response::cryptoGetAccountRecords(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::cryptoGetAccountRecords(super::CryptoGetAccountRecords::CryptoGetAccountRecordsResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::cryptoGetAccountRecords(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cryptoGetAccountRecords(&mut self) -> super::CryptoGetAccountRecords::CryptoGetAccountRecordsResponse {
        if self.has_cryptoGetAccountRecords() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::cryptoGetAccountRecords(v)) => v,
                _ => panic!(),
            }
        } else {
            super::CryptoGetAccountRecords::CryptoGetAccountRecordsResponse::new()
        }
    }

    pub fn get_cryptoGetAccountRecords(&self) -> &super::CryptoGetAccountRecords::CryptoGetAccountRecordsResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::cryptoGetAccountRecords(ref v)) => v,
            _ => super::CryptoGetAccountRecords::CryptoGetAccountRecordsResponse::default_instance(),
        }
    }

    // .proto.CryptoGetInfoResponse cryptoGetInfo = 9;

    pub fn clear_cryptoGetInfo(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_cryptoGetInfo(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::cryptoGetInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cryptoGetInfo(&mut self, v: super::CryptoGetInfo::CryptoGetInfoResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::cryptoGetInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cryptoGetInfo(&mut self) -> &mut super::CryptoGetInfo::CryptoGetInfoResponse {
        if let ::std::option::Option::Some(Response_oneof_response::cryptoGetInfo(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::cryptoGetInfo(super::CryptoGetInfo::CryptoGetInfoResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::cryptoGetInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cryptoGetInfo(&mut self) -> super::CryptoGetInfo::CryptoGetInfoResponse {
        if self.has_cryptoGetInfo() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::cryptoGetInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            super::CryptoGetInfo::CryptoGetInfoResponse::new()
        }
    }

    pub fn get_cryptoGetInfo(&self) -> &super::CryptoGetInfo::CryptoGetInfoResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::cryptoGetInfo(ref v)) => v,
            _ => super::CryptoGetInfo::CryptoGetInfoResponse::default_instance(),
        }
    }

    // .proto.CryptoGetClaimResponse cryptoGetClaim = 10;

    pub fn clear_cryptoGetClaim(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_cryptoGetClaim(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::cryptoGetClaim(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cryptoGetClaim(&mut self, v: super::CryptoGetClaim::CryptoGetClaimResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::cryptoGetClaim(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cryptoGetClaim(&mut self) -> &mut super::CryptoGetClaim::CryptoGetClaimResponse {
        if let ::std::option::Option::Some(Response_oneof_response::cryptoGetClaim(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::cryptoGetClaim(super::CryptoGetClaim::CryptoGetClaimResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::cryptoGetClaim(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cryptoGetClaim(&mut self) -> super::CryptoGetClaim::CryptoGetClaimResponse {
        if self.has_cryptoGetClaim() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::cryptoGetClaim(v)) => v,
                _ => panic!(),
            }
        } else {
            super::CryptoGetClaim::CryptoGetClaimResponse::new()
        }
    }

    pub fn get_cryptoGetClaim(&self) -> &super::CryptoGetClaim::CryptoGetClaimResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::cryptoGetClaim(ref v)) => v,
            _ => super::CryptoGetClaim::CryptoGetClaimResponse::default_instance(),
        }
    }

    // .proto.CryptoGetStakersResponse cryptoGetProxyStakers = 11;

    pub fn clear_cryptoGetProxyStakers(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_cryptoGetProxyStakers(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::cryptoGetProxyStakers(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_cryptoGetProxyStakers(&mut self, v: super::CryptoGetStakers::CryptoGetStakersResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::cryptoGetProxyStakers(v))
    }

    // Mutable pointer to the field.
    pub fn mut_cryptoGetProxyStakers(&mut self) -> &mut super::CryptoGetStakers::CryptoGetStakersResponse {
        if let ::std::option::Option::Some(Response_oneof_response::cryptoGetProxyStakers(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::cryptoGetProxyStakers(super::CryptoGetStakers::CryptoGetStakersResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::cryptoGetProxyStakers(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_cryptoGetProxyStakers(&mut self) -> super::CryptoGetStakers::CryptoGetStakersResponse {
        if self.has_cryptoGetProxyStakers() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::cryptoGetProxyStakers(v)) => v,
                _ => panic!(),
            }
        } else {
            super::CryptoGetStakers::CryptoGetStakersResponse::new()
        }
    }

    pub fn get_cryptoGetProxyStakers(&self) -> &super::CryptoGetStakers::CryptoGetStakersResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::cryptoGetProxyStakers(ref v)) => v,
            _ => super::CryptoGetStakers::CryptoGetStakersResponse::default_instance(),
        }
    }

    // .proto.FileGetContentsResponse fileGetContents = 12;

    pub fn clear_fileGetContents(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_fileGetContents(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::fileGetContents(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fileGetContents(&mut self, v: super::FileGetContents::FileGetContentsResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::fileGetContents(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fileGetContents(&mut self) -> &mut super::FileGetContents::FileGetContentsResponse {
        if let ::std::option::Option::Some(Response_oneof_response::fileGetContents(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::fileGetContents(super::FileGetContents::FileGetContentsResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::fileGetContents(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fileGetContents(&mut self) -> super::FileGetContents::FileGetContentsResponse {
        if self.has_fileGetContents() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::fileGetContents(v)) => v,
                _ => panic!(),
            }
        } else {
            super::FileGetContents::FileGetContentsResponse::new()
        }
    }

    pub fn get_fileGetContents(&self) -> &super::FileGetContents::FileGetContentsResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::fileGetContents(ref v)) => v,
            _ => super::FileGetContents::FileGetContentsResponse::default_instance(),
        }
    }

    // .proto.FileGetInfoResponse fileGetInfo = 13;

    pub fn clear_fileGetInfo(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_fileGetInfo(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::fileGetInfo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fileGetInfo(&mut self, v: super::FileGetInfo::FileGetInfoResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::fileGetInfo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fileGetInfo(&mut self) -> &mut super::FileGetInfo::FileGetInfoResponse {
        if let ::std::option::Option::Some(Response_oneof_response::fileGetInfo(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::fileGetInfo(super::FileGetInfo::FileGetInfoResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::fileGetInfo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fileGetInfo(&mut self) -> super::FileGetInfo::FileGetInfoResponse {
        if self.has_fileGetInfo() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::fileGetInfo(v)) => v,
                _ => panic!(),
            }
        } else {
            super::FileGetInfo::FileGetInfoResponse::new()
        }
    }

    pub fn get_fileGetInfo(&self) -> &super::FileGetInfo::FileGetInfoResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::fileGetInfo(ref v)) => v,
            _ => super::FileGetInfo::FileGetInfoResponse::default_instance(),
        }
    }

    // .proto.TransactionGetReceiptResponse transactionGetReceipt = 14;

    pub fn clear_transactionGetReceipt(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_transactionGetReceipt(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::transactionGetReceipt(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_transactionGetReceipt(&mut self, v: super::TransactionGetReceipt::TransactionGetReceiptResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::transactionGetReceipt(v))
    }

    // Mutable pointer to the field.
    pub fn mut_transactionGetReceipt(&mut self) -> &mut super::TransactionGetReceipt::TransactionGetReceiptResponse {
        if let ::std::option::Option::Some(Response_oneof_response::transactionGetReceipt(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::transactionGetReceipt(super::TransactionGetReceipt::TransactionGetReceiptResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::transactionGetReceipt(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_transactionGetReceipt(&mut self) -> super::TransactionGetReceipt::TransactionGetReceiptResponse {
        if self.has_transactionGetReceipt() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::transactionGetReceipt(v)) => v,
                _ => panic!(),
            }
        } else {
            super::TransactionGetReceipt::TransactionGetReceiptResponse::new()
        }
    }

    pub fn get_transactionGetReceipt(&self) -> &super::TransactionGetReceipt::TransactionGetReceiptResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::transactionGetReceipt(ref v)) => v,
            _ => super::TransactionGetReceipt::TransactionGetReceiptResponse::default_instance(),
        }
    }

    // .proto.TransactionGetRecordResponse transactionGetRecord = 15;

    pub fn clear_transactionGetRecord(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_transactionGetRecord(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::transactionGetRecord(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_transactionGetRecord(&mut self, v: super::TransactionGetRecord::TransactionGetRecordResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::transactionGetRecord(v))
    }

    // Mutable pointer to the field.
    pub fn mut_transactionGetRecord(&mut self) -> &mut super::TransactionGetRecord::TransactionGetRecordResponse {
        if let ::std::option::Option::Some(Response_oneof_response::transactionGetRecord(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::transactionGetRecord(super::TransactionGetRecord::TransactionGetRecordResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::transactionGetRecord(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_transactionGetRecord(&mut self) -> super::TransactionGetRecord::TransactionGetRecordResponse {
        if self.has_transactionGetRecord() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::transactionGetRecord(v)) => v,
                _ => panic!(),
            }
        } else {
            super::TransactionGetRecord::TransactionGetRecordResponse::new()
        }
    }

    pub fn get_transactionGetRecord(&self) -> &super::TransactionGetRecord::TransactionGetRecordResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::transactionGetRecord(ref v)) => v,
            _ => super::TransactionGetRecord::TransactionGetRecordResponse::default_instance(),
        }
    }

    // .proto.TransactionGetFastRecordResponse transactionGetFastRecord = 16;

    pub fn clear_transactionGetFastRecord(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_transactionGetFastRecord(&self) -> bool {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::transactionGetFastRecord(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_transactionGetFastRecord(&mut self, v: super::TransactionGetFastRecord::TransactionGetFastRecordResponse) {
        self.response = ::std::option::Option::Some(Response_oneof_response::transactionGetFastRecord(v))
    }

    // Mutable pointer to the field.
    pub fn mut_transactionGetFastRecord(&mut self) -> &mut super::TransactionGetFastRecord::TransactionGetFastRecordResponse {
        if let ::std::option::Option::Some(Response_oneof_response::transactionGetFastRecord(_)) = self.response {
        } else {
            self.response = ::std::option::Option::Some(Response_oneof_response::transactionGetFastRecord(super::TransactionGetFastRecord::TransactionGetFastRecordResponse::new()));
        }
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::transactionGetFastRecord(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_transactionGetFastRecord(&mut self) -> super::TransactionGetFastRecord::TransactionGetFastRecordResponse {
        if self.has_transactionGetFastRecord() {
            match self.response.take() {
                ::std::option::Option::Some(Response_oneof_response::transactionGetFastRecord(v)) => v,
                _ => panic!(),
            }
        } else {
            super::TransactionGetFastRecord::TransactionGetFastRecordResponse::new()
        }
    }

    pub fn get_transactionGetFastRecord(&self) -> &super::TransactionGetFastRecord::TransactionGetFastRecordResponse {
        match self.response {
            ::std::option::Option::Some(Response_oneof_response::transactionGetFastRecord(ref v)) => v,
            _ => super::TransactionGetFastRecord::TransactionGetFastRecordResponse::default_instance(),
        }
    }
}

impl ::protobuf::Message for Response {
    fn is_initialized(&self) -> bool {
        if let Some(Response_oneof_response::getByKey(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::getBySolidityID(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::contractCallLocal(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::contractGetBytecodeResponse(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::contractGetInfo(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::contractGetRecordsResponse(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::cryptogetAccountBalance(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::cryptoGetAccountRecords(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::cryptoGetInfo(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::cryptoGetClaim(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::cryptoGetProxyStakers(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::fileGetContents(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::fileGetInfo(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::transactionGetReceipt(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::transactionGetRecord(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Response_oneof_response::transactionGetFastRecord(ref v)) = self.response {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::getByKey(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::getBySolidityID(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::contractCallLocal(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::contractGetBytecodeResponse(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::contractGetInfo(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::contractGetRecordsResponse(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::cryptogetAccountBalance(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::cryptoGetAccountRecords(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::cryptoGetInfo(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::cryptoGetClaim(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::cryptoGetProxyStakers(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::fileGetContents(is.read_message()?));
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::fileGetInfo(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::transactionGetReceipt(is.read_message()?));
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::transactionGetRecord(is.read_message()?));
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.response = ::std::option::Option::Some(Response_oneof_response::transactionGetFastRecord(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &Response_oneof_response::getByKey(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::getBySolidityID(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::contractCallLocal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::contractGetBytecodeResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::contractGetInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::contractGetRecordsResponse(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::cryptogetAccountBalance(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::cryptoGetAccountRecords(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::cryptoGetInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::cryptoGetClaim(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::cryptoGetProxyStakers(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::fileGetContents(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::fileGetInfo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::transactionGetReceipt(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::transactionGetRecord(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Response_oneof_response::transactionGetFastRecord(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.response {
            match v {
                &Response_oneof_response::getByKey(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::getBySolidityID(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::contractCallLocal(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::contractGetBytecodeResponse(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::contractGetInfo(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::contractGetRecordsResponse(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::cryptogetAccountBalance(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::cryptoGetAccountRecords(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::cryptoGetInfo(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::cryptoGetClaim(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::cryptoGetProxyStakers(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::fileGetContents(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::fileGetInfo(ref v) => {
                    os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::transactionGetReceipt(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::transactionGetRecord(ref v) => {
                    os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Response_oneof_response::transactionGetFastRecord(ref v) => {
                    os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Response {
        Response::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::GetByKey::GetByKeyResponse>(
                    "getByKey",
                    Response::has_getByKey,
                    Response::get_getByKey,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::GetBySolidityID::GetBySolidityIDResponse>(
                    "getBySolidityID",
                    Response::has_getBySolidityID,
                    Response::get_getBySolidityID,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::ContractCallLocal::ContractCallLocalResponse>(
                    "contractCallLocal",
                    Response::has_contractCallLocal,
                    Response::get_contractCallLocal,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::ContractGetBytecode::ContractGetBytecodeResponse>(
                    "contractGetBytecodeResponse",
                    Response::has_contractGetBytecodeResponse,
                    Response::get_contractGetBytecodeResponse,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::ContractGetInfo::ContractGetInfoResponse>(
                    "contractGetInfo",
                    Response::has_contractGetInfo,
                    Response::get_contractGetInfo,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::ContractGetRecords::ContractGetRecordsResponse>(
                    "contractGetRecordsResponse",
                    Response::has_contractGetRecordsResponse,
                    Response::get_contractGetRecordsResponse,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::CryptoGetAccountBalance::CryptoGetAccountBalanceResponse>(
                    "cryptogetAccountBalance",
                    Response::has_cryptogetAccountBalance,
                    Response::get_cryptogetAccountBalance,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::CryptoGetAccountRecords::CryptoGetAccountRecordsResponse>(
                    "cryptoGetAccountRecords",
                    Response::has_cryptoGetAccountRecords,
                    Response::get_cryptoGetAccountRecords,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::CryptoGetInfo::CryptoGetInfoResponse>(
                    "cryptoGetInfo",
                    Response::has_cryptoGetInfo,
                    Response::get_cryptoGetInfo,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::CryptoGetClaim::CryptoGetClaimResponse>(
                    "cryptoGetClaim",
                    Response::has_cryptoGetClaim,
                    Response::get_cryptoGetClaim,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::CryptoGetStakers::CryptoGetStakersResponse>(
                    "cryptoGetProxyStakers",
                    Response::has_cryptoGetProxyStakers,
                    Response::get_cryptoGetProxyStakers,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::FileGetContents::FileGetContentsResponse>(
                    "fileGetContents",
                    Response::has_fileGetContents,
                    Response::get_fileGetContents,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::FileGetInfo::FileGetInfoResponse>(
                    "fileGetInfo",
                    Response::has_fileGetInfo,
                    Response::get_fileGetInfo,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::TransactionGetReceipt::TransactionGetReceiptResponse>(
                    "transactionGetReceipt",
                    Response::has_transactionGetReceipt,
                    Response::get_transactionGetReceipt,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::TransactionGetRecord::TransactionGetRecordResponse>(
                    "transactionGetRecord",
                    Response::has_transactionGetRecord,
                    Response::get_transactionGetRecord,
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::TransactionGetFastRecord::TransactionGetFastRecordResponse>(
                    "transactionGetFastRecord",
                    Response::has_transactionGetFastRecord,
                    Response::get_transactionGetFastRecord,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Response>(
                    "Response",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Response {
        static mut instance: ::protobuf::lazy::Lazy<Response> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Response,
        };
        unsafe {
            instance.get(Response::new)
        }
    }
}

impl ::protobuf::Clear for Response {
    fn clear(&mut self) {
        self.clear_getByKey();
        self.clear_getBySolidityID();
        self.clear_contractCallLocal();
        self.clear_contractGetBytecodeResponse();
        self.clear_contractGetInfo();
        self.clear_contractGetRecordsResponse();
        self.clear_cryptogetAccountBalance();
        self.clear_cryptoGetAccountRecords();
        self.clear_cryptoGetInfo();
        self.clear_cryptoGetClaim();
        self.clear_cryptoGetProxyStakers();
        self.clear_fileGetContents();
        self.clear_fileGetInfo();
        self.clear_transactionGetReceipt();
        self.clear_transactionGetRecord();
        self.clear_transactionGetFastRecord();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Response {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Response {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0eResponse.proto\x12\x05proto\x1a\x0eGetByKey.proto\x1a\x15GetBySoli\
    dityID.proto\x1a\x17ContractCallLocal.proto\x1a\x19ContractGetBytecode.p\
    roto\x1a\x15ContractGetInfo.proto\x1a\x18ContractGetRecords.proto\x1a\
    \x1dCryptoGetAccountBalance.proto\x1a\x1dCryptoGetAccountRecords.proto\
    \x1a\x13CryptoGetInfo.proto\x1a\x14CryptoGetClaim.proto\x1a\x16CryptoGet\
    Stakers.proto\x1a\x15FileGetContents.proto\x1a\x11FileGetInfo.proto\x1a\
    \x1bTransactionGetReceipt.proto\x1a\x1aTransactionGetRecord.proto\x1a\
    \x1eTransactionGetFastRecord.proto\"\xe0\n\n\x08Response\x125\n\x08getBy\
    Key\x18\x01\x20\x01(\x0b2\x17.proto.GetByKeyResponseH\0R\x08getByKey\x12\
    J\n\x0fgetBySolidityID\x18\x02\x20\x01(\x0b2\x1e.proto.GetBySolidityIDRe\
    sponseH\0R\x0fgetBySolidityID\x12P\n\x11contractCallLocal\x18\x03\x20\
    \x01(\x0b2\x20.proto.ContractCallLocalResponseH\0R\x11contractCallLocal\
    \x12f\n\x1bcontractGetBytecodeResponse\x18\x05\x20\x01(\x0b2\".proto.Con\
    tractGetBytecodeResponseH\0R\x1bcontractGetBytecodeResponse\x12J\n\x0fco\
    ntractGetInfo\x18\x04\x20\x01(\x0b2\x1e.proto.ContractGetInfoResponseH\0\
    R\x0fcontractGetInfo\x12c\n\x1acontractGetRecordsResponse\x18\x06\x20\
    \x01(\x0b2!.proto.ContractGetRecordsResponseH\0R\x1acontractGetRecordsRe\
    sponse\x12b\n\x17cryptogetAccountBalance\x18\x07\x20\x01(\x0b2&.proto.Cr\
    yptoGetAccountBalanceResponseH\0R\x17cryptogetAccountBalance\x12b\n\x17c\
    ryptoGetAccountRecords\x18\x08\x20\x01(\x0b2&.proto.CryptoGetAccountReco\
    rdsResponseH\0R\x17cryptoGetAccountRecords\x12D\n\rcryptoGetInfo\x18\t\
    \x20\x01(\x0b2\x1c.proto.CryptoGetInfoResponseH\0R\rcryptoGetInfo\x12G\n\
    \x0ecryptoGetClaim\x18\n\x20\x01(\x0b2\x1d.proto.CryptoGetClaimResponseH\
    \0R\x0ecryptoGetClaim\x12W\n\x15cryptoGetProxyStakers\x18\x0b\x20\x01(\
    \x0b2\x1f.proto.CryptoGetStakersResponseH\0R\x15cryptoGetProxyStakers\
    \x12J\n\x0ffileGetContents\x18\x0c\x20\x01(\x0b2\x1e.proto.FileGetConten\
    tsResponseH\0R\x0ffileGetContents\x12>\n\x0bfileGetInfo\x18\r\x20\x01(\
    \x0b2\x1a.proto.FileGetInfoResponseH\0R\x0bfileGetInfo\x12\\\n\x15transa\
    ctionGetReceipt\x18\x0e\x20\x01(\x0b2$.proto.TransactionGetReceiptRespon\
    seH\0R\x15transactionGetReceipt\x12Y\n\x14transactionGetRecord\x18\x0f\
    \x20\x01(\x0b2#.proto.TransactionGetRecordResponseH\0R\x14transactionGet\
    Record\x12e\n\x18transactionGetFastRecord\x18\x10\x20\x01(\x0b2'.proto.T\
    ransactionGetFastRecordResponseH\0R\x18transactionGetFastRecordB\n\n\x08\
    responseB&\n\"com.hederahashgraph.api.proto.javaP\x01b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
