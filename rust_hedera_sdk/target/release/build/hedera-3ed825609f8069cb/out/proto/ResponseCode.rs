// This file is generated by rust-protobuf 2.3.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ResponseCodeEnum {
    OK = 0,
    INVALID_TRANSACTION = 1,
    PAYER_ACCOUNT_NOT_FOUND = 2,
    INVALID_NODE_ACCOUNT = 3,
    TRANSACTION_EXPIRED = 4,
    INVALID_TRANSACTION_START = 5,
    INVALID_TRANSACTION_DURATION = 6,
    INVALID_SIGNATURE = 7,
    MEMO_TOO_LONG = 8,
    INSUFFICIENT_TX_FEE = 9,
    INSUFFICIENT_PAYER_BALANCE = 10,
    DUPLICATE_TRANSACTION = 11,
    BUSY = 12,
    NOT_SUPPORTED = 13,
    INVALID_FILE_ID = 14,
    INVALID_ACCOUNT_ID = 15,
    INVALID_CONTRACT_ID = 16,
    INVALID_TRANSACTION_ID = 17,
    RECEIPT_NOT_FOUND = 18,
    RECORD_NOT_FOUND = 19,
    INVALID_SOLIDITY_ID = 20,
    UNKNOWN = 21,
    SUCCESS = 22,
    FAIL_INVALID = 23,
    FAIL_FEE = 24,
    FAIL_BALANCE = 25,
    KEY_REQUIRED = 26,
    BAD_ENCODING = 27,
    INSUFFICIENT_ACCOUNT_BALANCE = 28,
    INVALID_SOLIDITY_ADDRESS = 29,
    INSUFFICIENT_GAS = 30,
    CONTRACT_SIZE_LIMIT_EXCEEDED = 31,
    LOCAL_CALL_MODIFICATION_EXCEPTION = 32,
    CONTRACT_REVERT_EXECUTED = 33,
    CONTRACT_EXECUTION_EXCEPTION = 34,
    INVALID_RECEIVING_NODE_ACCOUNT = 35,
    MISSING_QUERY_HEADER = 36,
    ACCOUNT_UPDATE_FAILED = 37,
    INVALID_KEY_ENCODING = 38,
    NULL_SOLIDITY_ADDRESS = 39,
    CONTRACT_UPDATE_FAILED = 40,
    INVALID_QUERY_HEADER = 41,
    INVALID_FEE_SUBMITTED = 42,
    INVALID_PAYER_SIGNATURE = 43,
    KEY_NOT_PROVIDED = 44,
    INVALID_EXPIRATION_TIME = 45,
    NO_WACL_KEY = 46,
    FILE_CONTENT_EMPTY = 47,
    INVALID_ACCOUNT_AMOUNTS = 48,
    EMPTY_TRANSACTION_BODY = 49,
    INVALID_TRANSACTION_BODY = 50,
}

impl ::protobuf::ProtobufEnum for ResponseCodeEnum {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResponseCodeEnum> {
        match value {
            0 => ::std::option::Option::Some(ResponseCodeEnum::OK),
            1 => ::std::option::Option::Some(ResponseCodeEnum::INVALID_TRANSACTION),
            2 => ::std::option::Option::Some(ResponseCodeEnum::PAYER_ACCOUNT_NOT_FOUND),
            3 => ::std::option::Option::Some(ResponseCodeEnum::INVALID_NODE_ACCOUNT),
            4 => ::std::option::Option::Some(ResponseCodeEnum::TRANSACTION_EXPIRED),
            5 => ::std::option::Option::Some(ResponseCodeEnum::INVALID_TRANSACTION_START),
            6 => ::std::option::Option::Some(ResponseCodeEnum::INVALID_TRANSACTION_DURATION),
            7 => ::std::option::Option::Some(ResponseCodeEnum::INVALID_SIGNATURE),
            8 => ::std::option::Option::Some(ResponseCodeEnum::MEMO_TOO_LONG),
            9 => ::std::option::Option::Some(ResponseCodeEnum::INSUFFICIENT_TX_FEE),
            10 => ::std::option::Option::Some(ResponseCodeEnum::INSUFFICIENT_PAYER_BALANCE),
            11 => ::std::option::Option::Some(ResponseCodeEnum::DUPLICATE_TRANSACTION),
            12 => ::std::option::Option::Some(ResponseCodeEnum::BUSY),
            13 => ::std::option::Option::Some(ResponseCodeEnum::NOT_SUPPORTED),
            14 => ::std::option::Option::Some(ResponseCodeEnum::INVALID_FILE_ID),
            15 => ::std::option::Option::Some(ResponseCodeEnum::INVALID_ACCOUNT_ID),
            16 => ::std::option::Option::Some(ResponseCodeEnum::INVALID_CONTRACT_ID),
            17 => ::std::option::Option::Some(ResponseCodeEnum::INVALID_TRANSACTION_ID),
            18 => ::std::option::Option::Some(ResponseCodeEnum::RECEIPT_NOT_FOUND),
            19 => ::std::option::Option::Some(ResponseCodeEnum::RECORD_NOT_FOUND),
            20 => ::std::option::Option::Some(ResponseCodeEnum::INVALID_SOLIDITY_ID),
            21 => ::std::option::Option::Some(ResponseCodeEnum::UNKNOWN),
            22 => ::std::option::Option::Some(ResponseCodeEnum::SUCCESS),
            23 => ::std::option::Option::Some(ResponseCodeEnum::FAIL_INVALID),
            24 => ::std::option::Option::Some(ResponseCodeEnum::FAIL_FEE),
            25 => ::std::option::Option::Some(ResponseCodeEnum::FAIL_BALANCE),
            26 => ::std::option::Option::Some(ResponseCodeEnum::KEY_REQUIRED),
            27 => ::std::option::Option::Some(ResponseCodeEnum::BAD_ENCODING),
            28 => ::std::option::Option::Some(ResponseCodeEnum::INSUFFICIENT_ACCOUNT_BALANCE),
            29 => ::std::option::Option::Some(ResponseCodeEnum::INVALID_SOLIDITY_ADDRESS),
            30 => ::std::option::Option::Some(ResponseCodeEnum::INSUFFICIENT_GAS),
            31 => ::std::option::Option::Some(ResponseCodeEnum::CONTRACT_SIZE_LIMIT_EXCEEDED),
            32 => ::std::option::Option::Some(ResponseCodeEnum::LOCAL_CALL_MODIFICATION_EXCEPTION),
            33 => ::std::option::Option::Some(ResponseCodeEnum::CONTRACT_REVERT_EXECUTED),
            34 => ::std::option::Option::Some(ResponseCodeEnum::CONTRACT_EXECUTION_EXCEPTION),
            35 => ::std::option::Option::Some(ResponseCodeEnum::INVALID_RECEIVING_NODE_ACCOUNT),
            36 => ::std::option::Option::Some(ResponseCodeEnum::MISSING_QUERY_HEADER),
            37 => ::std::option::Option::Some(ResponseCodeEnum::ACCOUNT_UPDATE_FAILED),
            38 => ::std::option::Option::Some(ResponseCodeEnum::INVALID_KEY_ENCODING),
            39 => ::std::option::Option::Some(ResponseCodeEnum::NULL_SOLIDITY_ADDRESS),
            40 => ::std::option::Option::Some(ResponseCodeEnum::CONTRACT_UPDATE_FAILED),
            41 => ::std::option::Option::Some(ResponseCodeEnum::INVALID_QUERY_HEADER),
            42 => ::std::option::Option::Some(ResponseCodeEnum::INVALID_FEE_SUBMITTED),
            43 => ::std::option::Option::Some(ResponseCodeEnum::INVALID_PAYER_SIGNATURE),
            44 => ::std::option::Option::Some(ResponseCodeEnum::KEY_NOT_PROVIDED),
            45 => ::std::option::Option::Some(ResponseCodeEnum::INVALID_EXPIRATION_TIME),
            46 => ::std::option::Option::Some(ResponseCodeEnum::NO_WACL_KEY),
            47 => ::std::option::Option::Some(ResponseCodeEnum::FILE_CONTENT_EMPTY),
            48 => ::std::option::Option::Some(ResponseCodeEnum::INVALID_ACCOUNT_AMOUNTS),
            49 => ::std::option::Option::Some(ResponseCodeEnum::EMPTY_TRANSACTION_BODY),
            50 => ::std::option::Option::Some(ResponseCodeEnum::INVALID_TRANSACTION_BODY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResponseCodeEnum] = &[
            ResponseCodeEnum::OK,
            ResponseCodeEnum::INVALID_TRANSACTION,
            ResponseCodeEnum::PAYER_ACCOUNT_NOT_FOUND,
            ResponseCodeEnum::INVALID_NODE_ACCOUNT,
            ResponseCodeEnum::TRANSACTION_EXPIRED,
            ResponseCodeEnum::INVALID_TRANSACTION_START,
            ResponseCodeEnum::INVALID_TRANSACTION_DURATION,
            ResponseCodeEnum::INVALID_SIGNATURE,
            ResponseCodeEnum::MEMO_TOO_LONG,
            ResponseCodeEnum::INSUFFICIENT_TX_FEE,
            ResponseCodeEnum::INSUFFICIENT_PAYER_BALANCE,
            ResponseCodeEnum::DUPLICATE_TRANSACTION,
            ResponseCodeEnum::BUSY,
            ResponseCodeEnum::NOT_SUPPORTED,
            ResponseCodeEnum::INVALID_FILE_ID,
            ResponseCodeEnum::INVALID_ACCOUNT_ID,
            ResponseCodeEnum::INVALID_CONTRACT_ID,
            ResponseCodeEnum::INVALID_TRANSACTION_ID,
            ResponseCodeEnum::RECEIPT_NOT_FOUND,
            ResponseCodeEnum::RECORD_NOT_FOUND,
            ResponseCodeEnum::INVALID_SOLIDITY_ID,
            ResponseCodeEnum::UNKNOWN,
            ResponseCodeEnum::SUCCESS,
            ResponseCodeEnum::FAIL_INVALID,
            ResponseCodeEnum::FAIL_FEE,
            ResponseCodeEnum::FAIL_BALANCE,
            ResponseCodeEnum::KEY_REQUIRED,
            ResponseCodeEnum::BAD_ENCODING,
            ResponseCodeEnum::INSUFFICIENT_ACCOUNT_BALANCE,
            ResponseCodeEnum::INVALID_SOLIDITY_ADDRESS,
            ResponseCodeEnum::INSUFFICIENT_GAS,
            ResponseCodeEnum::CONTRACT_SIZE_LIMIT_EXCEEDED,
            ResponseCodeEnum::LOCAL_CALL_MODIFICATION_EXCEPTION,
            ResponseCodeEnum::CONTRACT_REVERT_EXECUTED,
            ResponseCodeEnum::CONTRACT_EXECUTION_EXCEPTION,
            ResponseCodeEnum::INVALID_RECEIVING_NODE_ACCOUNT,
            ResponseCodeEnum::MISSING_QUERY_HEADER,
            ResponseCodeEnum::ACCOUNT_UPDATE_FAILED,
            ResponseCodeEnum::INVALID_KEY_ENCODING,
            ResponseCodeEnum::NULL_SOLIDITY_ADDRESS,
            ResponseCodeEnum::CONTRACT_UPDATE_FAILED,
            ResponseCodeEnum::INVALID_QUERY_HEADER,
            ResponseCodeEnum::INVALID_FEE_SUBMITTED,
            ResponseCodeEnum::INVALID_PAYER_SIGNATURE,
            ResponseCodeEnum::KEY_NOT_PROVIDED,
            ResponseCodeEnum::INVALID_EXPIRATION_TIME,
            ResponseCodeEnum::NO_WACL_KEY,
            ResponseCodeEnum::FILE_CONTENT_EMPTY,
            ResponseCodeEnum::INVALID_ACCOUNT_AMOUNTS,
            ResponseCodeEnum::EMPTY_TRANSACTION_BODY,
            ResponseCodeEnum::INVALID_TRANSACTION_BODY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("ResponseCodeEnum", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ResponseCodeEnum {
}

impl ::std::default::Default for ResponseCodeEnum {
    fn default() -> Self {
        ResponseCodeEnum::OK
    }
}

impl ::protobuf::reflect::ProtobufValue for ResponseCodeEnum {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x12ResponseCode.proto\x12\x05proto*\x85\n\n\x10ResponseCodeEnum\x12\
    \x06\n\x02OK\x10\0\x12\x17\n\x13INVALID_TRANSACTION\x10\x01\x12\x1b\n\
    \x17PAYER_ACCOUNT_NOT_FOUND\x10\x02\x12\x18\n\x14INVALID_NODE_ACCOUNT\
    \x10\x03\x12\x17\n\x13TRANSACTION_EXPIRED\x10\x04\x12\x1d\n\x19INVALID_T\
    RANSACTION_START\x10\x05\x12\x20\n\x1cINVALID_TRANSACTION_DURATION\x10\
    \x06\x12\x15\n\x11INVALID_SIGNATURE\x10\x07\x12\x11\n\rMEMO_TOO_LONG\x10\
    \x08\x12\x17\n\x13INSUFFICIENT_TX_FEE\x10\t\x12\x1e\n\x1aINSUFFICIENT_PA\
    YER_BALANCE\x10\n\x12\x19\n\x15DUPLICATE_TRANSACTION\x10\x0b\x12\x08\n\
    \x04BUSY\x10\x0c\x12\x11\n\rNOT_SUPPORTED\x10\r\x12\x13\n\x0fINVALID_FIL\
    E_ID\x10\x0e\x12\x16\n\x12INVALID_ACCOUNT_ID\x10\x0f\x12\x17\n\x13INVALI\
    D_CONTRACT_ID\x10\x10\x12\x1a\n\x16INVALID_TRANSACTION_ID\x10\x11\x12\
    \x15\n\x11RECEIPT_NOT_FOUND\x10\x12\x12\x14\n\x10RECORD_NOT_FOUND\x10\
    \x13\x12\x17\n\x13INVALID_SOLIDITY_ID\x10\x14\x12\x0b\n\x07UNKNOWN\x10\
    \x15\x12\x0b\n\x07SUCCESS\x10\x16\x12\x10\n\x0cFAIL_INVALID\x10\x17\x12\
    \x0c\n\x08FAIL_FEE\x10\x18\x12\x10\n\x0cFAIL_BALANCE\x10\x19\x12\x10\n\
    \x0cKEY_REQUIRED\x10\x1a\x12\x10\n\x0cBAD_ENCODING\x10\x1b\x12\x20\n\x1c\
    INSUFFICIENT_ACCOUNT_BALANCE\x10\x1c\x12\x1c\n\x18INVALID_SOLIDITY_ADDRE\
    SS\x10\x1d\x12\x14\n\x10INSUFFICIENT_GAS\x10\x1e\x12\x20\n\x1cCONTRACT_S\
    IZE_LIMIT_EXCEEDED\x10\x1f\x12%\n!LOCAL_CALL_MODIFICATION_EXCEPTION\x10\
    \x20\x12\x1c\n\x18CONTRACT_REVERT_EXECUTED\x10!\x12\x20\n\x1cCONTRACT_EX\
    ECUTION_EXCEPTION\x10\"\x12\"\n\x1eINVALID_RECEIVING_NODE_ACCOUNT\x10#\
    \x12\x18\n\x14MISSING_QUERY_HEADER\x10$\x12\x19\n\x15ACCOUNT_UPDATE_FAIL\
    ED\x10%\x12\x18\n\x14INVALID_KEY_ENCODING\x10&\x12\x19\n\x15NULL_SOLIDIT\
    Y_ADDRESS\x10'\x12\x1a\n\x16CONTRACT_UPDATE_FAILED\x10(\x12\x18\n\x14INV\
    ALID_QUERY_HEADER\x10)\x12\x19\n\x15INVALID_FEE_SUBMITTED\x10*\x12\x1b\n\
    \x17INVALID_PAYER_SIGNATURE\x10+\x12\x14\n\x10KEY_NOT_PROVIDED\x10,\x12\
    \x1b\n\x17INVALID_EXPIRATION_TIME\x10-\x12\x0f\n\x0bNO_WACL_KEY\x10.\x12\
    \x16\n\x12FILE_CONTENT_EMPTY\x10/\x12\x1b\n\x17INVALID_ACCOUNT_AMOUNTS\
    \x100\x12\x1a\n\x16EMPTY_TRANSACTION_BODY\x101\x12\x1c\n\x18INVALID_TRAN\
    SACTION_BODY\x102B&\n\"com.hederahashgraph.api.proto.javaP\x01b\x06proto\
    3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
